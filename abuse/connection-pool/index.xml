<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Connection Pool on XS-Leaks Wiki</title><link>https://webapppentestguidelines.github.io/xs-leaks/abuse/connection-pool/</link><description>Recent content in Connection Pool on XS-Leaks Wiki</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 01 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://webapppentestguidelines.github.io/xs-leaks/abuse/connection-pool/index.xml" rel="self" type="application/rss+xml"/><item><title>Connection Pool</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/connection-pool/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/connection-pool/</guid><description>network timingを測定する方法の一つとして、ブラウザのソケットプールを悪用する方法があります。 ブラウザはサーバと通信するために、ソケットを利用します。 ハードウェアやその上で動作するOSのリソースには限りがあるため、ブラウザにも制限をかけざるを得ません。
この制限の存在を悪用するために、攻撃者は下記のようなことができます。
ブラウザの制限を確認する。 単に接続をハングアップさせる \(255\) のリクエストを別々のホストに実行して、長時間 \(255\) のソケットをブロックする。 ターゲットページに対するリクエストを実行して、 \(256^{番目}\) のソケットを利用する。 他のホストへの \(257^{番目}\) のリクエストを実行します。(step2、3で)すべてのソケットが使用されているので、このリクエストは、プールが利用可能なソケットを受け取るまで待機する必要があります。この待ち時間は、ターゲットページに属する \(256^{番目}\) のソケットのネットワークタイミングを、攻撃者に提供します。これが動作するのは、ステップ2の \(255\) 個のソケットがまだブロックされているので、ステップ3のソケットの解放によってプールが利用可能なソケットを受信した場合です。 \(256^{番目}\) のソケットを解放する時間は、リクエストを完了するのにかかった時間と直結しています。 対策 # SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ❌ ❌ ❌ ❌ info
partitioned cachesと同様に、リソースの&amp;quot;site/originごとの分割&amp;quot;の原理をソケットプールに拡張することを、いくつかのブラウザが検討しています。 参考文献 #</description></item></channel></rss>