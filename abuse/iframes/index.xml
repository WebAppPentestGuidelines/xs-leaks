<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>iframes on XS-Leaks Wiki</title><link>https://webapppentestguidelines.github.io/xs-leaks/abuse/iframes/</link><description>Recent content in iframes on XS-Leaks Wiki</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 01 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://webapppentestguidelines.github.io/xs-leaks/abuse/iframes/index.xml" rel="self" type="application/rss+xml"/><item><title>Frame Counting</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/frame-counting/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/frame-counting/</guid><description>ウィンドウの参照により、クロスオリジンのページが他のページのいくつかの属性にアクセスできます。 これらの参照は、iframeとwindow.openを使用または許可するときに利用可能となります。 この参照は、同一生成元ポリシーを尊重し続けるため、ウィンドウに関する（限定的な）情報を提供します。
アクセス可能な属性の1つは、ウィンドウ内のフレーム数を提供するwindow.lengthです。 この属性は、ページに関する貴重な情報を攻撃者に提供します。
Webサイトでは一般的にフレーム（またはiframes）を使用しますが、この選択は必ずしもセキュリティ上の問題を意味するわけではありません。 しかし、Webサイトがユーザの情報に応じてページのフレーム数を変更する場合があります。 例えば、GETパラメータと利用者のデータに応じてレイアウトを変えるようなページで起こりえます。 攻撃者は、異なるページで window.length の値を測定することにより、被害者に関する情報を推測することが可能かもしれません。
コード # 以下のコードは、クロスサイトのページにおけるフレーム数に関する情報にアクセスする方法を示しています。
// ウィンドウへの参照を取得する var win = window.open(&amp;#39;https://example.org&amp;#39;); // ページが読み込まれるのを待つ setTimeout(() =&amp;gt; { // 読み込まれたiframeの数を読み取る console.log(&amp;#34;%d iframes detected&amp;#34;, win.length); }, 2000); 攻撃の対策 # 場合によっては、異なるアプリケーション状態が同じ数のフレームを持つことで、攻撃者がそれらを区別できないようにすることができます。 ただし、ページの読み込み中にフレーム数を連続的に記録することで、攻撃者に情報をリークする可能性があるパターンを示す可能性もあります。
// ウィンドウへの参照を取得する var win = window.open(&amp;#34;https://example.org&amp;#34;); var pattern = []; // ループ内で、60ms間隔でiframeの数を登録する var recorder = setInterval(() =&amp;gt; { pattern.push(win.length) }, 60); // 6秒後にループを解除する setTimeout(() =&amp;gt; { clearInterval(recorder); console.log(&amp;#34;The pattern is: %s&amp;#34;, pattern.join(&amp;#39;, &amp;#39;)); }, 6 * 1000); 事例 # フレームカウント攻撃の例としては、以下のようなものがあります。</description></item><item><title>Navigations</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/navigations/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/navigations/</guid><description>クロスサイトのページで画面遷移がトリガーされたか（または、そうでないか）を検出することは攻撃者にとって有用です。例えば、ウェブサイトはユーザの状態に依存(#case-scenarios)して、あるエンドポイントで画面遷移をトリガーする可能性があります。
どのような画面遷移が発生したかを検出することで攻撃者以下の様なことが可能になります。
iframeを使用してonloadイベントがトリガーされた回数を数える。 ウィンドウへの参照を通じてアクセス可能なhistory.lengthの値をチェックする。この値は被害者のhistory.pushStateや通常の画面遷移によって変更された履歴の数を提供しています。攻撃者はhistory.lengthの値を取得するためにウィンドウへの参照のlocationをターゲットのウェブサイトに変更し、そしてSame-Originに戻すことによって最後に値を読み取ります。 ダウンロードトリガー # エンドポイントがContent-Disposition: attachment ヘッダを設定すると、ブラウザにレスポンスをナビゲートさせるのではなくファイルとしてダウンロードすることを指示します。この挙動が発生したかを検出すると、結果が被害者の状態に依存する場合に攻撃者に機密情報をリークできる可能性があります。
ダウンロードバー # Chromeベースのブラウザではファイルをダウンロードする際に、ブラウザのウィンドウ下部にダウンロードの進捗を示すバーがウィンドウと一体化して表示されます。攻撃者ウィンドウの高さを監視することでダウンロードバーが開いているかどうかを検出することができます。
// ウィンドウの現在の高さを読み取る var screenHeight = window.innerHeight; // ダウンロードのトリガーとなるページを読み込む window.open(&amp;#39;https://example.org&amp;#39;); // タブの読み込みを待つ setTimeout(() =&amp;gt; { // ダウンロードバーが表示された場合、すべてのタブの高さが小さくなります if (window.innerHeight &amp;lt; screenHeight) { console.log(&amp;#39;Download bar detected&amp;#39;); } else { console.log(&amp;#39;Download bar not detected&amp;#39;); } }, 2000); important
この攻撃は、自動ダウンロード機能が有効になっているChromeベースのブラウザでのみ有効です。加えてこの攻撃はユーザがダウンロードばーばを能動的に閉じないと再検出できないため、繰り返し行うことはできません。 iframeを利用したダウンロード遷移 # Content-Disposition: attachment ヘッダをテストするもう一つの方法は遷移が発生したかどうかをチェックすることです。仮にページの読み込みによってダウンロードが発生した場合、遷移は発生せずウィンドウは同一オリジン内に留まります。
以下のコードは、そのような遷移が発生したかを検出しダウンロードが試行されたかを検出します。
// ダウンロード試行時のテスト先URLを設定する var url = &amp;#39;https://example.org/&amp;#39;; // onloadイベントを計測するための外側のiframeを作成する var iframe = document.createElement(&amp;#39;iframe&amp;#39;); document.body.appendChild(iframe); // ダウンロードの試行をテストするために、内側のiframeを作成 iframe.srcdoc = `&amp;lt;iframe src=&amp;#34;${url}&amp;#34; &amp;gt;&amp;lt;/iframe&amp;gt;`; iframe.</description></item><item><title>Network Timing</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/network-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/network-timing/</guid><description>ネットワーク タイミングのサイドチャネルは、ウェブが誕生したときから存在していました。これらの攻撃は、ブラウザがperformance.now()のような高精度のタイマーを出荷し始めたときに、新しい注目を集め、時とともに異なるレベルの影響を持つようになりました。
タイミング測定値を得るために、攻撃者は暗黙的または明示的なクロックを使用する必要があります。これらのクロックは、XS-Leaksの目的では通常交換可能であり、精度と利用可能性が異なるだけです。簡単のために、この記事では、すべてのモダンブラウザに存在する明示的なクロックであるperformance.now()APIを使用することを想定しています。
このサイドチャネルにより、攻撃者はクロスサイトリクエストが完了するまでにかかった時間から情報を推測することができます。ネットワークのタイミング測定は、ユーザーの状態によって変化する可能性があり、通常は下記の要素に連動します。
リソースサイズ バックエンドでの計算時間 サブリソースの数とサイズ キャッシュの状態. tip
クロックの種類については、クロックの記事で詳しく説明しています。 モダンなWebのタイミング攻撃 # performance.now()は、リクエストの実行にかかる時間を測定するために使用できます。
// クロックを開始します。 var start = performance.now() // fetchリクエストが完了するまでの時間を計測します。 fetch(&amp;#39;https://example.org&amp;#39;, { mode: &amp;#39;no-cors&amp;#39;, credentials: &amp;#39;include&amp;#39; }).then(() =&amp;gt; { // fetch終了した時点で時間差を計算します。 var time = performance.now() - start; console.log(&amp;#34;The request took %d ms.&amp;#34;, time); }); Onloadイベント # 同じような処理で、リソースを取得するのにかかる時間を測定するには、単に onload イベントを監視することで可能です。
// 時間が欲しいページを指すscript要素を作成します。 var script = document.createElement(&amp;#39;script&amp;#39;); script.src = &amp;#34;https://example.org&amp;#34;; document.body.appendChild(script); // クロックを開始します。 var start = performance.now(); // スクリプトがロードされたら、リクエストが完了するまでの時間を計算します。 script.onload = () =&amp;gt; { var time = performance.</description></item><item><title>Cache Probing</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/cache-probing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/cache-probing/</guid><description>Cache Probingは、あるリソースがブラウザによってキャッシュされているかどうかを検知する手法です。そのコンセプトは、初期のWeb1から知られており、当初はタイミングの差異を検知することに基づいていました。
ユーザがWebサイトに訪れると、画像、スクリプト、そしてHTMLコンテンツなどの様々なリソースが取得され、それらは(特定の条件下で)ブラウザによってキャッシュされます。この最適化により、ブラウザはこれらのリソースを再度要求することなくディスクから提供するため、その後のナビゲーションが高速化されます。もし攻撃者がどのリソースがキャッシュされているかを検知できれば、この情報を基に、ユーザが特定のページにアクセスしたことがあるかどうかをリークできます。
Cache Probingのバリエーションとして、Error Eventsを悪用することにより、より正確でインパクトのある攻撃を実行することができます。
攻撃の原理 # 攻撃者は、あるユーザーがあるSNSを訪問したかどうかを知りたいと考えています。
そのSNSにアクセスすると、いくつかのサブリソースがキャッシュされます。 ユーザが、SNSが通常取得するリソースを取得する攻撃者のページを訪問する。 Network Timing XS-Leakの手法を用いて、攻撃者のページはキャッシュからの応答（つまりステップ1が起こった）とネットワークからの応答（つまりステップ1が起こらなかった）の違いを検出することができます。（応答がキャッシュからの場合、遅延は顕著に短くなります。） Error EventsによるCache Probing # Error Events2を利用したキャッシュプロービングは、より正確な攻撃を可能にします。このアプローチでは、時間の計測に頼らず、Error Eventsといくつかのサーバサイドの挙動を活用して、あるリソースがキャッシュされたかどうかを検出します。この攻撃は、以下のステップを必要とします。
ブラウザキャッシュからのリソースを無効化する。このステップは、攻撃が別の訪問で以前にキャッシュされたリソースを考慮しないことを確認するために必要です。 ユーザーの状態によって異なる項目がキャッシュされるようなリクエストを実行する。例えば、ユーザーがログインしている場合にのみ、特定の画像を含むページをロードする。このリクエストは、&amp;lt;link rel=prerender...で対象のウェブサイトに移動したり、iframeでウェブサイトを埋め込んだり、window.openで新しいウィンドウを開くことで発生させることができる。 サーバが拒否するようなリクエストを引き起こす。例えば、長大なRefererヘッダを含んでいて、サーバーがリクエストを拒否するような場合です。もし、ステップ2でリソースがキャッシュされていれば、このリクエストはエラーイベントを発生させることなく、成功します。 キャッシュの無効化 # キャッシュからのリソースを無効にするには、攻撃者はそのサブリソースを取得する際にサーバーがエラーを返すようにする必要があります。これを実現するには、いくつかの方法があります。
ブラウザによってリクエストが開始され、新しいコンテンツを受け取る前にAbortController.abort()で中止された cache:'reload'オプション付きのフェッチリクエスト 長大なRefererヘッダと 'cache':'reload'を持つリクエスト。ブラウザはこれを防ぐためにリファラの長さに上限を設けているので、これはうまくいかないかもしれません。 POSTリクエストに fetch no-cors を指定した場合。エラーが返されない場合でも、ブラウザがキャッシュを無効化することがあります。 Content-Type、Accept、Accept-Languageなど、サーバーを失敗させる可能性のあるリクエストヘッダ。（よりアプリケーションに依存します） その他のリクエストプロパティ これらの方法のいくつかは、しばしばブラウザのバグとみなされていそうです。(例: this bug).
Origin ReflectionによるCORS error # Origin Reflectionは、グローバルにアクセス可能なリソースに、リクエストを初期化したオリジンを反映したAccess-Control-Allow-Origin（ACAO）ヘッダを付与する挙動のことです。これは、CORSの設定ミス3と考えることができ、ブラウザのキャッシュにリソースが存在するかどうかを検知するのに使用できます。
info
例えば、Flask frameworkにおいて、origin refrectionはデフォルトの動作になっています。 もし server.com にホストされているリソースが target.com からリクエストされた場合、オリジンはレスポンスヘッダに次のように反映されるでしょう。Access-Control-Allow-Origin: target.com といった具合です。リソースがキャッシュされている場合、この情報はリソースと一緒にブラウザのキャッシュに保存されます。これにより、もし attacker.com が同じリソースを取得しようとした場合、2つの可能性があります。
リソースがキャッシュにない場合：リソースは Access-Control-Allow-Origin: attacker.com ヘッダーとともにフェッチされ、保存される可能性があります。 リソースがすでにキャッシュにある：フェッチ試行はキャッシュからリソースをフェッチしようとするが、要求しているオリジンと ACAO ヘッダーの値の不一致によりCORSエラーが起こる。（target.comが期待されているが、実際に提供されたのはattacker.com 。）以下に、この脆弱性を悪用して被害者のブラウザのキャッシュ状態を推測するコード例を示します。 // この関数は、単にURLを受け取り、CORS モードでfetchします。 // fetchでエラーが発生した場合、attacker.</description></item><item><title>Execution Timing</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/execution-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/execution-timing/</guid><description>ブラウザ上でのJavaScriptの実行時間を測定することで、攻撃者は特定のイベントがいつ発生したか、ある操作にどれくらいの時間がかかったかといった情報を得ることができます。
イベントループのタイミング # JavaScriptの並行処理モデルは、single-threaded event loopに基づいており、これは一度に一つのタスクしか実行できないことを意味します。 例えば、ある時間のかかるタスクがイベントループをブロックした場合、UIスレッドが枯渇した結果として、ユーザーはページがフリーズしたように感じることがあります。 他のタスクはブロックされたタスクが終了するまで待たなければなりません。 各ブラウザは異なるプロセスモデルを実装しているので、ウェブサイトによっては、その関係によって異なるスレッド（およびイベントループ）で実行されることがあります。
このモデルを悪用して、クロスオリジンページから秘密を盗みだす手法があります。
イベントプールで次に実行されるまでの時間を測定することで、異なるオリジンのコードが実行されるまでの時間を推測する。攻撃者は固定されたプロパティを持つイベントをイベントループ12に送り続け、プールが空になると最終的にディスパッチされます。他のオリジンは同じプールにイベントをディスパッチし、ここで攻撃者はそのタスクの一つで遅延が発生したかどうかを検出することで、時間差を推測します。 攻撃者が制御する文字列によって前記の機密情報が比較される場合、クロスオリジンページから機密情報を盗む。このリークは、1文字ずつの文字列比較2のイベントループで時間差を比較した結果です（前出の手法を使用）。process isolationを行わないブラウザでは、異なるオリジン間のクロスウィンドウ通信が同じスレッドで実行され、同じイベントループを共有します。 important
process isolationの仕組みがあるブラウザでは、後者の攻撃の可能性はすでにありません。このような仕組みは、現在Chromiumベースのブラウザでは Site Isolationのみで、Firefox にはProject Fission という名前で間もなく導入される予定です。 Busy Event Loop # 別の手法として、スレッドのイベントループをブロックし、イベントループが再び利用可能になるまでの時間を計測する方法があります。 この手法の主な利点の1つは、攻撃者のオリジンが他のオリジンの実行に影響を与えることができるため、Site Isolationを回避できることです。この攻撃は次のように動作します。
対象のウェブサイトをwindow.openで別ウィンドウに表示するか、iframe内に表示する。(Framing Protectionsが設定されていない場合) 長い計算が始まるのを待つ。 Framing Protectionsに関係なく、同じサイトのページをiframe内に読み込む 攻撃者は、(手順3の)iframeがonloadイベントをトリガーするのにかかった時間を計ることで、ターゲットのウェブサイトが実行された時間を検出できます。(Network Timing of step 3 should be minimal) 両方のナビゲーションは同じコンテキストで発生し、それらは同じサイトであるため、同じスレッドで実行され、同じイベントループを共有します。（それらは互いにブロックすることができます。）
// 新しいウィンドウを開いて、example.comのイベントループを // ウィンドウがブロックする時間を測定する window.open(&amp;#39;https://example.org/expensive&amp;#39;); // TODO: タイムアウトなどでコストの掛かるウィンドウがロードされるのを待ちます。 var ifr = document.createElement(&amp;#39;iframe&amp;#39;); ifr.src = &amp;#34;https://example.org&amp;#34;; document.body.appendChild(ifr); // 初期時間の測定 var start = performance.now(); ifr.onload = () =&amp;gt; { // iframeが読み込まれたら、時間差を計算する var time = performance.</description></item><item><title>Hybrid Timing</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/hybrid-timing/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/hybrid-timing/</guid><description>ハイブリッド・タイミング攻撃では、攻撃者は最終的なタイミング測定に影響を与える一連の要素の合計を測定することができます。これらの要素には以下のものがあります。
ネットワークの遅延 ドキュメントのパース サブリソースの検索と処理 コード実行 アプリケーションによって値が異なる要素もあります。つまり、Network Timing はバックエンドの処理が多いページでより重要かもしれませんし、一方 Execution Timing はブラウザ内でデータを処理し表示するアプリケーションでより重要かもしれないのです。攻撃者は、より正確な測定値を得るために、これらの要因のいくつかを排除することも可能です。例えば、攻撃者はページを iframe として埋め込むことによってすべてのサブリソースを事前にロードし（ブラウザにサブリソースをキャッシュさせる）、その後、それらのサブリソースの取得によって生じる遅延を除外した2度目の計測を行えます。
Frameタイミング攻撃(Hybrid) # ページがFraming Protectionsを設定していない場合、攻撃者はすべての要素を考慮したハイブリッドな計測結果を取得できます。この攻撃はNetwork-based Attackと似ていますが、リソースが取得されると、ブラウザによってページがレンダリングされて実行されます（サブリソースの取得と JavaScript の実行が行われる）。このシナリオでは、onloadイベントは（サブリソースとスクリプトの実行を含めて）ページが完全にロードされたときだけトリガーされます。
var iframe = document.createElement(&amp;#39;iframe&amp;#39;); // 配送先のWebサイトのURLを設定する iframe.src = &amp;#34;https://example.org&amp;#34;; document.body.appendChild(iframe); // リクエストが初期化されるまでの時間を計測する var start = performance.now(); iframe.onload = () =&amp;gt; { // iframeが読み込まれたら、時間差を計算する var time = performance.now() - start; console.log(&amp;#34;The iframe and subresources took %d ms to load.&amp;#34;, time) } 対策 # Attack Alternative SameSite Cookies (Lax) COOP Framing Protections Isolation Policies Frame Timing (Hybrid) ✔️ ❌ ✔️ FIP</description></item><item><title>ID Attribute</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/id-attribute/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/id-attribute/</guid><description>id属性はHTML要素を識別するために広く利用されています。残念ながらクロスオリジンのウェブサイトでfocusイベントとURLフラグメントを利用することによって、ページのどこにid属性が与えられているかを決定することができます。例えば、https://example.com/foo#barが読み込まれると、ブラウザはid=&amp;quot;bar&amp;quot;が与えられた要素までスクロールしようとします。これはクロスオリジンのサイトで定義したiframeでhttps://example.com/foo#barを読み込むことによって検出することができます。もし、 id=&amp;quot;bar&amp;quot; を持つ要素がある場合は、 focus イベントが発生します。 focus イベントもまた同じ目的で使用することができます1。
いくつかのウェブアプリケーションはfocusable要素にid属性を設定しており、ユーザ情報の開示につながります。これらのid属性には、ユーザに直接関連する機密情報やユーザの状態（アカウントの状態）に関連する情報を含めることができます。
コード # 以下のコードは別のサイトからID属性を検出する例を示しています：
// onblurイベントをリッスン onblur = () =&amp;gt; { alert(&amp;#39;Focus was lost, so there is a focusable element with the specified ID&amp;#39;); } var ifr = document.createElement(&amp;#39;iframe&amp;#39;); // ページに id=&amp;#34;x&amp;#34; のフォーカス可能な要素がある場合、フォーカスを得ることができます。 // 例： &amp;lt;input id=&amp;#34;x&amp;#34; value=&amp;#34;test&amp;#34; /&amp;gt; ifr.src = &amp;#39;https://example.org/#x&amp;#39;; document.body.appendChild(ifr); info
上記の手法はFireFoxではうまく動作しない可能性があります。 攻撃シナリオ # id属性を利用した攻撃は以下のような物があります。
とある銀行がモバイルデバイスのセッションを認証するために短い数字のワンタイムPin(OTP)を生成することを許可しています。この銀行のページはクライアントにPINコードを表示するためのbutton要素のidにOTPコードそのものを使用していました。この挙動を悪用し、すべてのオプションをブルートフォースすることでOTPコードを窃取し、ユーザアカウントを侵害することができます。 とあるウェブアプリケーションが、プレミアムアカウントのステータスを持つユーザや、特定の性別のユーザである場合、あらかじめ定義されたidとHTML要素の組み合わせを利用します。攻撃者は、被害者のページに特定のidがあるかを検出し、被害者のアカウント情報を漏えいさせることができます。 対策 # Document Policies SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ✔️ ✔️ ✔️ ❌ FIP 参考文献 # Leaking IDs using focus, link&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Content-Type</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/historical/content-type/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/historical/content-type/</guid><description>リクエストのContent-Typeをリークすることで、攻撃者は2つのリクエストを区別できるようになります。
typeMustMatch # typeMustMatchはobject要素のtypeMustMatch属性を反映したブール値です。これは、オブジェクトを読み込む際に、リソースのContent-Typeがオブジェクトで提供されるものと同じかどうかを検証することで、特定の MIME タイプを強制しなければならないことを保証します。残念ながら、この強制は攻撃者がウェブサイトから返されるContent-Typeとステータスコードを漏らすことも可能にします 1。
根本的な原因 # 以下のスニペットを考えると、https://target/api で返された Content-Type が type のものと一致しない場合や、サーバが 200 以外のステータスを返した場合には、 not_loaded がレンダリングされるでしょう。
&amp;lt;object type=&amp;#34;application/json&amp;#34; data=&amp;#34;https://example.org&amp;#34; typemustmatch&amp;gt; not_loaded &amp;lt;/object&amp;gt; 問題 # 攻撃者は、すべての条件が満たされたときに起こるオブジェクトのレンダリングを検出することによって、ウェブサイトのContent-Typeとステータスコードをリークできます。攻撃者は、(ステータスコード200で)オブジェクトがレンダリングされるとき、0ではないであろうclientHeightとclientWidthの値をチェックできます。typeMustMatchはリソースを読み込む際に、サーバーがステータス200を返すことを要求するので、Error Events XS-Leaksと同様にエラーページを検出することが可能でしょう。
以下の例では、iframe内にオブジェクトを埋め込み、iframeがonloadイベントをトリガーしたときにclientHeightとclientWidthの値をチェックすることでこの動作を検出する方法を示しています。
// 配送先のWebサイトのURLを設定する var url = &amp;#39;https://example.org&amp;#39;; // チェックしたいコンテンツタイプ var mime = &amp;#39;application/json&amp;#39;; var ifr = document.createElement(&amp;#39;iframe&amp;#39;); // オブジェクトがonloadイベントを発生させないので、iframe内にオブジェクトをロードする。 ifr.srcdoc = ` &amp;lt;object id=&amp;#34;obj&amp;#34; type=&amp;#34;${mime}&amp;#34; data=&amp;#34;${url}&amp;#34; typemustmatch&amp;gt; error &amp;lt;/object&amp;gt;`; document.body.appendChild(ifr); // iframeが読み込まれたら、オブジェクトの高さを読み取ります。 // もしそれが一行のテキストの高さであれば、リソースのContent Typeは`application/json`ではなかったということです。 // もしそうでなければ、それは`application/json`だったということです。 ifr.onload = () =&amp;gt; { console.</description></item><item><title>Scroll to Text Fragment</title><link>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/experiments/scroll-to-text-fragment/</link><pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate><guid>https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/experiments/scroll-to-text-fragment/</guid><description>Scroll to Text Fragment (STTF) は、ユーザーがウェブページのテキストの任意の部分へのリンクを作成できるWebプラットフォームの新機能です。フラグメント#:~:text=は、ブラウザによって強調表示されてビューポートに取り込まれるテキストスニペットを運びます。この機能は、攻撃者がこの動作の発生を検出できることで、新しいXS-Leakをもたらします。この問題は、Scroll to CSS SelectorのXS-Leakに非常によく似ています。
期待される課題・議論される課題 # この機能の仕様に関する初期の議論では、単純な実装でいくつかのXS-Leakをもたらせることが示されました1。この仕様では、様々な攻撃シナリオ2が考慮されており、Googleの研究結果も同様です3。この機能を実装する際、ブラウザが注意すべきXS-Leakの可能性の1つは、以下の通りです。
攻撃者は、ページをiframeとして埋め込むことで、親ドキュメントのonblurイベントを聞くことによって、ページがテキストにスクロールされたかどうかを検出することができます。この方法は、ID Attribute XS-Leakと類似しています。このシナリオは、Chromeの実装4では、トップレベルのナビゲーションで発生するフラグメントナビゲーションのみを許可しているため、緩和されています。 現在の課題 # warning
これらのXS-Leaksは、ターゲットページに何らかのマークアップを注入する必要があります。 STTFの開発過程で、フラグメントナビゲーションを検出するための新しい攻撃やトリックが発見されました。そのうちのいくつかは今でも有効です。
攻撃者が制御するiframeを埋め込んだWebページでは、テキストへのスクロールが発生したかどうかを攻撃者が判断することができるかもしれません。これは、IntersectionObserverAPIを使用して行うことができます5 2 3。 ページがレイジーローディングで画像を含む場合、攻撃者は画像が[ブラウザにキャッシュ]cached in the browserされているかどうかをチェックすることで、画像を含むフラグメントナビゲーションが発生したかどうかを検出することができます。これは、レイジーローディングの画像は、ビューポートに表示されたときにのみ取得（およびキャッシュ）されるため、機能します。 important
Scroll to Text Fragmentは、Chromeでのみ利用可能です。仕様書ドラフトは現在検討中です。 info
Scroll to Text Fragment XS-Leaksでは、ページ上に1つの単語が存在するかどうかを観察し、ユーザーがページに対して何らかの操作（例：マウスクリック）を行った場合にのみ、攻撃者は一度に1ビットの情報を抽出することが可能です。 なぜ問題なのか？ # 攻撃者はSTTFを悪用して、Webページに表示されるユーザーの個人情報を漏えいさせることができます。
事例シナリオ # あるユーザが国民健康保険制度のWebサイトにログインしており、そこでユーザの過去の病気や健康問題についての情報にアクセスすることが可能でした。攻撃者はユーザーをそのページの一つに誘い込み、STTFを使用してユーザーの健康状態の詳細を推測できる可能性があります。例えば、ある病名で検索した際に、ページスクロールを検知すると、その病名が被害者の病気であることを知ることができます。
対策 # Document Policies SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ✔️ ✔️ ❌ ✔️ RIP 🔗 NIP 参考文献 # Privacy concerns with proposal through inducing network requests, link&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item></channel></rss>