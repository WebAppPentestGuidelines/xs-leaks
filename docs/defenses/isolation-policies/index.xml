<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Isolation Policies on XS-Leaks Wiki</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/</link><description>Recent content in Isolation Policies on XS-Leaks Wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://xsleaks.dev/docs/defenses/isolation-policies/index.xml" rel="self" type="application/rss+xml"/><item><title>Resource Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/resource-isolation/</guid><description>Resource Isolation Policyは、外部のWebサイトがリソースを要求するのを防ぎます。このようなトラフィックをブロックすることで、CSRF、XSSI、XS-Leaks などの一般的な Web 脆弱性を軽減できます。このポリシーは、エンドポイントがクロスサイトコンテキストでロードされることを意図していないアプリケーションに対して有効にすることができ、アプリケーションから来るリソース要求だけでなく、直接の遷移も可能にします。
Fetch Metadataを用いた実装 # 以下のコードは、Fetch Metadata ヘッダーを使用したResource Isolation Policyの実装例を示しています:
# クロスサイトリクエストを拒否し、クリックジャッキングやXS-Leaks、他のバグから保護します def allow_request(req): # [OPTIONAL] クロスオリジンで提供されることを意図したパス/エンドポイントを除外する。 if req.path in (&amp;#39;/my_CORS_endpoint&amp;#39;, &amp;#39;/favicon.png&amp;#39;): return True # `Cross-Origin-Resource-Policy: same-site`を設定すると安全です。(考慮事項参照) # Fetch Metadataを送信しないブラウザからのリクエストを許可する if not req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-site&amp;#39;]: return True # same-siteやブラウザ経由のリクエストの許可 if req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-site&amp;#39;] in (&amp;#39;same-origin&amp;#39;, &amp;#39;same-site&amp;#39;, &amp;#39;none&amp;#39;): return True # 埋め込みを含むシンプルなトップレベルの遷移を許可する if req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-mode&amp;#39;] == &amp;#39;navigate&amp;#39; and req.method == &amp;#39;GET&amp;#39;: return True # その他のリクエストを拒否する return False 考慮事項 # Resource Isolation Policyから明示的に除外されていないすべてのリクエストに Cross-Origin-Resource-Policy: same-site レスポンスヘッダを設定しても問題ないはずです。CORPを参照してください。</description></item><item><title>Framing Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/framing-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/framing-isolation/</guid><description>Framing Isolation Policy は、Framing Protections のより厳格なバージョンで、ブラウザではなく、アプリケーションレベルでリクエストがブロックされます。これは、フレーム化を意図していないエンドポイントへのフレーム化リクエストをブロックすることで、さまざまな攻撃（XSSI、CSRF、XS-Leaksなど）から保護するために設計されています。
Resource Isolation Policy と組み合わせることで、XS-Leaksの攻撃対象領域を効果的に絞り込むことができます。
tip
フレーム化できないエンドポイントをすべて拒否するのではなく、例えば 信頼できる発信元からこのページを訪問したことを確認する といったアクションを確認するようユーザーに促すことで、バックグラウンドでの攻撃のリスクを軽減し、同時にアプリケーションの意図しない破損を防ぐことができます。 tip
Resource Isolation Policy と共に展開された場合、Framing Isolation Policy はウィンドウ参照（例 window.length）を利用したリークから保護しないため、COOP や Navigation Isolation Policy など他の画面遷移保護が役に立つことがあります。 Fetch Metadataを用いた実装 # 以下のコードは、アプリケーションによる Framing Isolation Policy の実装例を示しています。
# CSRF、XSSI、XS-Leaksなどのバグから保護するために、クロスサイトリクエストを拒否します。 def allow_request(req): # Fetch Metadataを送信しないブラウザからのリクエストを許可する。 if not req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-site&amp;#39;]: return True if not req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-mode&amp;#39;]: return True if not req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-dest&amp;#39;]: return True # 遷移以外のリクエストを許可する。 if req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-mode&amp;#39;] not in (&amp;#39;navigate&amp;#39;, &amp;#39;nested-navigate&amp;#39;): return True # 遷移以外のリクエストを許可する。 if req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-dest&amp;#39;] not in (&amp;#39;frame&amp;#39;, &amp;#39;iframe&amp;#39;, &amp;#39;embed&amp;#39;, &amp;#39;object&amp;#39;): return True # [OPTIONAL] クロスサイトで提供されることを意図したパス/エンドポイントを除外する。 if req.</description></item><item><title>Navigation Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/navigation-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/navigation-isolation/</guid><description>Navigation Isolation Policy は、クロスサイトウィンドウコンテキストを利用した CSRFやクリックジャッキング、反射型XSS、XS-Leak を緩和することを目的としたサーバーサイドの保護機構です。これは厳格なポリシーであり、ハイパーリンクを介した遷移を含むすべてのクロスサイトの遷移をブロックするため、アプリケーションを破壊する可能性があります。
tip
すべてのクロスサイトインタラクションを拒否する代わりに、ユーザーにアクションを確認するよう促すことができます。例えば、このページを信頼できる発信元から訪れたことを確認することで 、バックグラウンドでの攻撃のリスクを軽減し、同時にアプリケーションの意図しない破壊を防ぐのに役立ちます。 Fetch Metadataを用いた実装 # 以下のコードは、Fetch Metadata ヘッダーを使用した Navigation Isolation Policy の実装例を示しています1:
# クロスサイトリクエストを拒否し、クリックジャッキングやXS-Leaks、他のバグから保護します def allow_request(req): # クロスサイトでないリクエストを許可する if req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-site&amp;#39;] != &amp;#39;cross-site&amp;#39;: return True # ホームページなど、遷移されることを意図したエンドポイントへのリクエストを許可する if req.path in whitelisted_paths: return True # 埋め込みを含むすべてのトップレベルクロスサイトの遷移をブロックする if req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-mode&amp;#39;] in (&amp;#39;navigate&amp;#39;, &amp;#39;nested-navigate&amp;#39;): return False # その他のリクエストを許可する return True 参考文献 # Fetch Metadata Request Headers playground, link&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>Strict Isolation Policy</title><link>https://xsleaks.dev/docs/defenses/isolation-policies/strict-isolation/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://xsleaks.dev/docs/defenses/isolation-policies/strict-isolation/</guid><description>Strict Isolation Policyは、すべてのクロスサイトインタラクション（ハイパーリンクを介したアプリケーションへの遷移を含む）から保護することを目的としています。これは非常に厳しいポリシーであり、アプリケーションが正常に機能しなくなる可能性があります。
tip
すべてのクロスサイトインタラクションを拒否する代わりに、ユーザーにアクションを確認するよう促すことができます。例えば、このページを信頼できる発信元から訪れたことを確認することで 、バックグラウンドでの攻撃のリスクを軽減し、同時にアプリケーションの意図しない破壊を防ぐのに役立ちます。
しかし、他のリソースはバックグラウンドで読み込まれるため、これは遷移のリクエストに対してのみ機能します。
Fetch Metadataを用いた実装 # 以下のコードは、アプリケーションによる Strict Isolation Policy の実装例を示しています:
# クロスオリジンリクエストを拒否し、CSRFやXSSI、他のバグから保護します def allow_request(req): # Fetch Metadataを送信しないブラウザからのリクエストを許可する if not req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-site&amp;#39;]: return True # cross-siteリクエストをブロック if req[&amp;#39;headers&amp;#39;][&amp;#39;sec-fetch-site&amp;#39;] == &amp;#39;cross-site&amp;#39;: return False # その他のリクエストを許可する return True SameSite cookiesを用いた実装 # もしサーバーがSameSite=strictフラグを持つCookieを送ると、このコードで示されるように、そのCokkieを含まないで返される全てのリクエストは拒否されることがあります。
# クロスオリジンリクエストを拒否し、CSRFやXSSI、他のバグから保護します def allow_request(req): if req[&amp;#39;cookies&amp;#39;][&amp;#39;strict-cookie&amp;#39;] == &amp;#39;true&amp;#39;: return True # strict Cookieを持たないリクエストはブロック return False Refererを用いた実装 # また、Referer ヘッダーを使用して、信頼できない送信元からのリクエストを拒否することも可能です:
# 信頼できないリファラーから来たリクエストを拒否する def allow_request(req): # referer ヘッダが信頼できるかどうかを確認する。つまりtrusted_referers ディクショナリに存在するかどうかを確認する。 if req[&amp;#39;headers&amp;#39;][&amp;#39;referer&amp;#39;] in trusted_referers: return True # strict Cookieを持たないリクエストをブロック return False important</description></item></channel></rss>