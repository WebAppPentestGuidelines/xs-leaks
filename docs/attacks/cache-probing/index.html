<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Cache Probingは、あるリソースがブラウザによってキャッシュされているかどうかを検知する手法です。そのコンセプトは、初期のWeb1から知られており、当初はタイミングの差異を検知することに基づいていました。
ユーザがWebサイトに訪れると、画像、スクリプト、そしてHTMLコンテンツなどの様々なリソースが取得され、それらは(特定の条件下で)ブラウザによってキャッシュされます。この最適化により、ブラウザはこれらのリソースを再度要求することなくディスクから提供するため、その後のナビゲーションが高速化されます。もし攻撃者がどのリソースがキャッシュされているかを検知できれば、この情報を基に、ユーザが特定のページにアクセスしたことがあるかどうかをリークできます。
Cache Probingのバリエーションとして、Error Eventsを悪用することにより、より正確でインパクトのある攻撃を実行することができます。
攻撃の原理 # 攻撃者は、あるユーザーがあるSNSを訪問したかどうかを知りたいと考えています。
そのSNSにアクセスすると、いくつかのサブリソースがキャッシュされます。 ユーザが、SNSが通常取得するリソースを取得する攻撃者のページを訪問する。 Network Timing XS-Leakの手法を用いて、攻撃者のページはキャッシュからの応答（つまりステップ1が起こった）とネットワークからの応答（つまりステップ1が起こらなかった）の違いを検出することができます。（応答がキャッシュからの場合、遅延は顕著に短くなります。） Error EventsによるCache Probing # Error Events2を利用したキャッシュプロービングは、より正確な攻撃を可能にします。このアプローチでは、時間の計測に頼らず、Error Eventsといくつかのサーバサイドの挙動を活用して、あるリソースがキャッシュされたかどうかを検出します。この攻撃は、以下のステップを必要とします。
ブラウザキャッシュからのリソースを無効化する。このステップは、攻撃が別の訪問で以前にキャッシュされたリソースを考慮しないことを確認するために必要です。 ユーザーの状態によって異なる項目がキャッシュされるようなリクエストを実行する。例えば、ユーザーがログインしている場合にのみ、特定の画像を含むページをロードする。このリクエストは、<link rel=prerender...で対象のウェブサイトに移動したり、iframeでウェブサイトを埋め込んだり、window.openで新しいウィンドウを開くことで発生させることができる。 サーバが拒否するようなリクエストを引き起こす。例えば、長大なRefererヘッダを含んでいて、サーバーがリクエストを拒否するような場合です。もし、ステップ2でリソースがキャッシュされていれば、このリクエストはエラーイベントを発生させることなく、成功します。 キャッシュの無効化 # キャッシュからのリソースを無効にするには、攻撃者はそのサブリソースを取得する際にサーバーがエラーを返すようにする必要があります。これを実現するには、いくつかの方法があります。
ブラウザによってリクエストが開始され、新しいコンテンツを受け取る前にAbortController.abort()で中止された cache:'reload'オプション付きのフェッチリクエスト 長大なRefererヘッダと 'cache':'reload'を持つリクエスト。ブラウザはこれを防ぐためにリファラの長さに上限を設けているので、これはうまくいかないかもしれません。 POSTリクエストに fetch no-cors を指定した場合。エラーが返されない場合でも、ブラウザがキャッシュを無効化することがあります。 Content-Type、Accept、Accept-Languageなど、サーバーを失敗させる可能性のあるリクエストヘッダ。（よりアプリケーションに依存します） その他のリクエストプロパティ これらの方法のいくつかは、しばしばブラウザのバグとみなされていそうです。(例: this bug).
Origin ReflectionによるCORS error # Origin Reflectionは、グローバルにアクセス可能なリソースに、リクエストを初期化したオリジンを反映したAccess-Control-Allow-Origin（ACAO）ヘッダを付与する挙動のことです。これは、CORSの設定ミス3と考えることができ、ブラウザのキャッシュにリソースが存在するかどうかを検知するのに使用できます。
info
例えば、Flask frameworkにおいて、origin refrectionはデフォルトの動作になっています。 もし server.com にホストされているリソースが target.com からリクエストされた場合、オリジンはレスポンスヘッダに次のように反映されるでしょう。Access-Control-Allow-Origin: target.com といった具合です。リソースがキャッシュされている場合、この情報はリソースと一緒にブラウザのキャッシュに保存されます。これにより、もし attacker.com が同じリソースを取得しようとした場合、2つの可能性があります。
リソースがキャッシュにない場合：リソースは Access-Control-Allow-Origin: attacker.com ヘッダーとともにフェッチされ、保存される可能性があります。 リソースがすでにキャッシュにある：フェッチ試行はキャッシュからリソースをフェッチしようとするが、要求しているオリジンと ACAO ヘッダーの値の不一致によりCORSエラーが起こる。（target.comが期待されているが、実際に提供されたのはattacker.com 。）以下に、この脆弱性を悪用して被害者のブラウザのキャッシュ状態を推測するコード例を示します。 // この関数は、単にURLを受け取り、CORS モードでfetchします。 // fetchでエラーが発生した場合、attacker."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Cache Probing"><meta property="og:description" content="Cache Probingは、あるリソースがブラウザによってキャッシュされているかどうかを検知する手法です。そのコンセプトは、初期のWeb1から知られており、当初はタイミングの差異を検知することに基づいていました。
ユーザがWebサイトに訪れると、画像、スクリプト、そしてHTMLコンテンツなどの様々なリソースが取得され、それらは(特定の条件下で)ブラウザによってキャッシュされます。この最適化により、ブラウザはこれらのリソースを再度要求することなくディスクから提供するため、その後のナビゲーションが高速化されます。もし攻撃者がどのリソースがキャッシュされているかを検知できれば、この情報を基に、ユーザが特定のページにアクセスしたことがあるかどうかをリークできます。
Cache Probingのバリエーションとして、Error Eventsを悪用することにより、より正確でインパクトのある攻撃を実行することができます。
攻撃の原理 # 攻撃者は、あるユーザーがあるSNSを訪問したかどうかを知りたいと考えています。
そのSNSにアクセスすると、いくつかのサブリソースがキャッシュされます。 ユーザが、SNSが通常取得するリソースを取得する攻撃者のページを訪問する。 Network Timing XS-Leakの手法を用いて、攻撃者のページはキャッシュからの応答（つまりステップ1が起こった）とネットワークからの応答（つまりステップ1が起こらなかった）の違いを検出することができます。（応答がキャッシュからの場合、遅延は顕著に短くなります。） Error EventsによるCache Probing # Error Events2を利用したキャッシュプロービングは、より正確な攻撃を可能にします。このアプローチでは、時間の計測に頼らず、Error Eventsといくつかのサーバサイドの挙動を活用して、あるリソースがキャッシュされたかどうかを検出します。この攻撃は、以下のステップを必要とします。
ブラウザキャッシュからのリソースを無効化する。このステップは、攻撃が別の訪問で以前にキャッシュされたリソースを考慮しないことを確認するために必要です。 ユーザーの状態によって異なる項目がキャッシュされるようなリクエストを実行する。例えば、ユーザーがログインしている場合にのみ、特定の画像を含むページをロードする。このリクエストは、<link rel=prerender...で対象のウェブサイトに移動したり、iframeでウェブサイトを埋め込んだり、window.openで新しいウィンドウを開くことで発生させることができる。 サーバが拒否するようなリクエストを引き起こす。例えば、長大なRefererヘッダを含んでいて、サーバーがリクエストを拒否するような場合です。もし、ステップ2でリソースがキャッシュされていれば、このリクエストはエラーイベントを発生させることなく、成功します。 キャッシュの無効化 # キャッシュからのリソースを無効にするには、攻撃者はそのサブリソースを取得する際にサーバーがエラーを返すようにする必要があります。これを実現するには、いくつかの方法があります。
ブラウザによってリクエストが開始され、新しいコンテンツを受け取る前にAbortController.abort()で中止された cache:'reload'オプション付きのフェッチリクエスト 長大なRefererヘッダと 'cache':'reload'を持つリクエスト。ブラウザはこれを防ぐためにリファラの長さに上限を設けているので、これはうまくいかないかもしれません。 POSTリクエストに fetch no-cors を指定した場合。エラーが返されない場合でも、ブラウザがキャッシュを無効化することがあります。 Content-Type、Accept、Accept-Languageなど、サーバーを失敗させる可能性のあるリクエストヘッダ。（よりアプリケーションに依存します） その他のリクエストプロパティ これらの方法のいくつかは、しばしばブラウザのバグとみなされていそうです。(例: this bug).
Origin ReflectionによるCORS error # Origin Reflectionは、グローバルにアクセス可能なリソースに、リクエストを初期化したオリジンを反映したAccess-Control-Allow-Origin（ACAO）ヘッダを付与する挙動のことです。これは、CORSの設定ミス3と考えることができ、ブラウザのキャッシュにリソースが存在するかどうかを検知するのに使用できます。
info
例えば、Flask frameworkにおいて、origin refrectionはデフォルトの動作になっています。 もし server.com にホストされているリソースが target.com からリクエストされた場合、オリジンはレスポンスヘッダに次のように反映されるでしょう。Access-Control-Allow-Origin: target.com といった具合です。リソースがキャッシュされている場合、この情報はリソースと一緒にブラウザのキャッシュに保存されます。これにより、もし attacker.com が同じリソースを取得しようとした場合、2つの可能性があります。
リソースがキャッシュにない場合：リソースは Access-Control-Allow-Origin: attacker.com ヘッダーとともにフェッチされ、保存される可能性があります。 リソースがすでにキャッシュにある：フェッチ試行はキャッシュからリソースをフェッチしようとするが、要求しているオリジンと ACAO ヘッダーの値の不一致によりCORSエラーが起こる。（target.comが期待されているが、実際に提供されたのはattacker.com 。）以下に、この脆弱性を悪用して被害者のブラウザのキャッシュ状態を推測するコード例を示します。 // この関数は、単にURLを受け取り、CORS モードでfetchします。 // fetchでエラーが発生した場合、attacker."><meta property="og:type" content="article"><meta property="og:url" content="https://xsleaks.dev/docs/attacks/cache-probing/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-06-14T18:56:55+09:00"><title>Cache Probing | XS-Leaks Wiki</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.1c9a9009be3c645cbccbe64eb0a90e28621e4118971d9a502db4aaa9bec96cfc.css integrity="sha256-HJqQCb48ZFy8y+ZOsKkOKGIeQRiXHZpQLbSqqb7JbPw="><script defer src=/en.search.min.191ebcb00d5c065f5f76aacb6507e71d1fe649eb2858975535f0380f4e272c40.js integrity="sha256-GR68sA1cBl9fdqrLZQfnHR/mSesoWJdVNfA4D04nLEA="></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>XS-Leaks Wiki</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>攻撃手法</span><ul><li><a href=/docs/attacks/xs-search/>XS-Search</a></li><li><a href=/docs/attacks/window-references/>Window References</a></li><li><a href=/docs/attacks/css-tricks/>CSS Tricks</a></li><li><a href=/docs/attacks/error-events/>Error Events</a></li><li><a href=/docs/attacks/frame-counting/>Frame Counting</a></li><li><a href=/docs/attacks/navigations/>Navigations</a></li><li><a href=/docs/attacks/cache-probing/ class=active>Cache Probing</a></li><li><a href=/docs/attacks/element-leaks/>Element leaks</a></li><li><a href=/docs/attacks/id-attribute/>ID Attribute</a></li><li><a href=/docs/attacks/postmessage-broadcasts/>postMessage Broadcasts</a></li><li><span>Browser Features</span><ul><li><a href=/docs/attacks/browser-features/corb/>CORB Leaks</a></li><li><a href=/docs/attacks/browser-features/corp/>CORP Leaks</a></li></ul></li><li><span>Timing Attacks</span><ul><li><a href=/docs/attacks/timing-attacks/clocks/>Clocks</a></li><li><a href=/docs/attacks/timing-attacks/network-timing/>Network Timing</a></li><li><a href=/docs/attacks/timing-attacks/performance-api/>Performance API</a></li><li><a href=/docs/attacks/timing-attacks/execution-timing/>Execution Timing</a></li><li><a href=/docs/attacks/timing-attacks/hybrid-timing/>Hybrid Timing</a></li><li><a href=/docs/attacks/timing-attacks/connection-pool/>Connection Pool</a></li></ul></li><li><a href=/docs/attacks/experiments/ class=collapsed>Experiments</a></li><li><a href=/docs/attacks/css-injection/>CSS Injection</a></li><li><a href=/docs/attacks/historical/ class=collapsed>Historical</a></li></ul></li><li class=book-section-flat><a href=/docs/defenses/>対策の仕組み</a><ul><li><a href=/docs/defenses/design-protections/>Application Design</a><ul><li><a href=/docs/defenses/design-protections/cache-protections/>Cache Protections</a></li><li><a href=/docs/defenses/design-protections/subresource-protections/>Subresource Protections</a></li></ul></li><li><a href=/docs/defenses/opt-in/>Opt-In Mechanisms</a><ul><li><a href=/docs/defenses/opt-in/fetch-metadata/>Fetch Metadata</a></li><li><a href=/docs/defenses/opt-in/coop/>Cross-Origin-Opener-Policy</a></li><li><a href=/docs/defenses/opt-in/corp/>Cross-Origin-Resource-Policy</a></li><li><a href=/docs/defenses/opt-in/xfo/>Framing Protections</a></li><li><a href=/docs/defenses/opt-in/same-site-cookies/>SameSite Cookies</a></li><li><a href=/docs/defenses/opt-in/document-policies/>Document Policies</a></li></ul></li><li><a href=/docs/defenses/isolation-policies/>Isolation Policies</a><ul><li><a href=/docs/defenses/isolation-policies/resource-isolation/>Resource Isolation Policy</a></li><li><a href=/docs/defenses/isolation-policies/framing-isolation/>Framing Isolation Policy</a></li><li><a href=/docs/defenses/isolation-policies/navigation-isolation/>Navigation Isolation Policy</a></li><li><a href=/docs/defenses/isolation-policies/strict-isolation/>Strict Isolation Policy</a></li></ul></li><li><a href=/docs/defenses/secure-defaults/>Secure Defaults</a><ul><li><a href=/docs/defenses/secure-defaults/corb/>Cross-Origin Read Blocking</a></li><li><a href=/docs/defenses/secure-defaults/partitioned-cache/>Partitioned HTTP Cache</a></li></ul></li></ul></li><li class=book-section-flat><a href=/docs/contributions/>Contributions</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Cache Probing</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#攻撃の原理>攻撃の原理</a></li><li><a href=#error-eventsによるcache-probing>Error EventsによるCache Probing</a><ul><li><a href=#キャッシュの無効化>キャッシュの無効化</a></li></ul></li><li><a href=#origin-reflectionによるcors-error>Origin ReflectionによるCORS error</a></li><li><a href=#fetch-with-abortcontroller>Fetch with AbortController</a></li><li><a href=#対策>対策</a></li><li><a href=#リアルワールドでの例>リアルワールドでの例</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></aside></header><article class=markdown><h1>Cache Probing</h1><div>Abuse
<a href=/abuse/window.open/>window.open</a>,
<a href=/abuse/error-events/>Error Events</a>,
<a href=/abuse/cache/>Cache</a>,
<a href=/abuse/iframes/>iframes</a>,
<a href=/abuse/abortcontroller/>AbortController</a></div><div>Category
<a href=/category/attack/>Attack</a></div><div>Defenses
<a href=/defenses/samesite-cookies/>SameSite Cookies</a>,
<a href=/defenses/vary-sec-fetch-site/>Vary: Sec-Fetch-Site</a>,
<a href=/defenses/subresource-protections/>Subresource Protections</a></div><p><p>Cache Probingは、あるリソースがブラウザによってキャッシュされているかどうかを検知する手法です。そのコンセプトは、初期のWeb<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>から知られており、当初はタイミングの差異を検知することに基づいていました。</p><p>ユーザがWebサイトに訪れると、画像、スクリプト、そしてHTMLコンテンツなどの様々なリソースが取得され、それらは(特定の条件下で)ブラウザによってキャッシュされます。この最適化により、ブラウザはこれらのリソースを再度要求することなくディスクから提供するため、その後のナビゲーションが高速化されます。もし攻撃者がどのリソースがキャッシュされているかを検知できれば、この情報を基に、ユーザが特定のページにアクセスしたことがあるかどうかをリークできます。</p><p>Cache Probingのバリエーションとして、<a href=https://xsleaks.dev/docs/attacks/error-events/>Error Events</a>を悪用することにより、より正確でインパクトのある攻撃を実行することができます。</p><h2 id=攻撃の原理>攻撃の原理
<a class=anchor href=#%e6%94%bb%e6%92%83%e3%81%ae%e5%8e%9f%e7%90%86>#</a></h2><p>攻撃者は、あるユーザーがあるSNSを訪問したかどうかを知りたいと考えています。</p><ol><li>そのSNSにアクセスすると、いくつかのサブリソースがキャッシュされます。</li><li>ユーザが、SNSが通常取得するリソースを取得する攻撃者のページを訪問する。</li><li><a href=https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/>Network Timing XS-Leak</a>の手法を用いて、攻撃者のページはキャッシュからの応答（つまりステップ1が起こった）とネットワークからの応答（つまりステップ1が起こらなかった）の違いを検出することができます。（応答がキャッシュからの場合、遅延は顕著に短くなります。）</li></ol><h2 id=error-eventsによるcache-probing>Error EventsによるCache Probing
<a class=anchor href=#error-events%e3%81%ab%e3%82%88%e3%82%8bcache-probing>#</a></h2><p><a href=https://xsleaks.dev/docs/attacks/error-events/>Error Events</a><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>を利用したキャッシュプロービングは、より正確な攻撃を可能にします。このアプローチでは、時間の計測に頼らず、<a href=https://xsleaks.dev/docs/attacks/error-events/>Error Events</a>といくつかのサーバサイドの挙動を活用して、あるリソースがキャッシュされたかどうかを検出します。この攻撃は、以下のステップを必要とします。</p><ol><li><a href=#invalidating-the-cache>ブラウザキャッシュ</a>からのリソースを無効化する。このステップは、攻撃が別の訪問で以前にキャッシュされたリソースを考慮しないことを確認するために必要です。</li><li>ユーザーの状態によって異なる項目がキャッシュされるようなリクエストを実行する。例えば、ユーザーがログインしている場合にのみ、特定の画像を含むページをロードする。このリクエストは、<code>&lt;link rel=prerender...</code>で対象のウェブサイトに移動したり、<code>iframe</code>でウェブサイトを埋め込んだり、<code>window.open</code>で新しいウィンドウを開くことで発生させることができる。</li><li>サーバが拒否するようなリクエストを引き起こす。例えば、<a href=https://lists.archive.carbon60.com/apache/users/316239>長大なRefererヘッダ</a>を含んでいて、サーバーがリクエストを拒否するような場合です。もし、ステップ2でリソースがキャッシュされていれば、このリクエストはエラーイベントを発生させることなく、成功します。</li></ol><h3 id=キャッシュの無効化>キャッシュの無効化
<a class=anchor href=#%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5%e3%81%ae%e7%84%a1%e5%8a%b9%e5%8c%96>#</a></h3><p>キャッシュからのリソースを無効にするには、攻撃者はそのサブリソースを取得する際にサーバーがエラーを返すようにする必要があります。これを実現するには、いくつかの方法があります。</p><ul><li>ブラウザによってリクエストが開始され、新しいコンテンツを受け取る前に<code>AbortController.abort()</code>で中止された <code>cache:'reload'</code>オプション付きのフェッチリクエスト</li><li><a href=https://lists.archive.carbon60.com/apache/users/31623>長大なRefererヘッダ</a>と <code>'cache':'reload'</code>を持つリクエスト。ブラウザはこれを防ぐためにリファラの長さに<a href=https://github.com/whatwg/fetch/issues/903>上限を設けている</a>ので、これはうまくいかないかもしれません。</li><li><code>POST</code>リクエストに <code>fetch</code> <code>no-cors</code> を指定した場合。エラーが返されない場合でも、ブラウザがキャッシュを無効化することがあります。</li><li>Content-Type、Accept、Accept-Languageなど、サーバーを失敗させる可能性のあるリクエストヘッダ。（よりアプリケーションに依存します）</li><li>その他のリクエストプロパティ</li></ul><p>これらの方法のいくつかは、しばしばブラウザのバグとみなされていそうです。(例: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=959789#c9">this bug</a>).</p><h2 id=origin-reflectionによるcors-error>Origin ReflectionによるCORS error
<a class=anchor href=#origin-reflection%e3%81%ab%e3%82%88%e3%82%8bcors-error>#</a></h2><p>Origin Reflectionは、グローバルにアクセス可能なリソースに、リクエストを初期化したオリジンを反映した<a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin>Access-Control-Allow-Origin（ACAO）</a>ヘッダを付与する挙動のことです。これは、CORSの設定ミス<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>と考えることができ、ブラウザのキャッシュにリソースが存在するかどうかを検知するのに使用できます。</p><blockquote class="book-hint2 info"><p class="hint-title info"><svg class="book-icon"><use href="/svg/hint-icons.svg#info-notice"/></svg><span>info</span></p>例えば、Flask frameworkにおいて、origin refrectionは<a href=https://flask-cors.readthedocs.io/en/latest/api.htm>デフォルトの動作</a>になっています。</blockquote><p>もし <code>server.com</code> にホストされているリソースが <code>target.com</code> からリクエストされた場合、オリジンはレスポンスヘッダに次のように反映されるでしょう。<code>Access-Control-Allow-Origin: target.com</code> といった具合です。リソースがキャッシュされている場合、この情報はリソースと一緒にブラウザのキャッシュに保存されます。これにより、もし <code>attacker.com</code> が同じリソースを取得しようとした場合、2つの可能性があります。</p><ul><li>リソースがキャッシュにない場合：リソースは <code>Access-Control-Allow-Origin: attacker.com</code> ヘッダーとともにフェッチされ、保存される可能性があります。</li><li>リソースがすでにキャッシュにある：フェッチ試行はキャッシュからリソースをフェッチしようとするが、要求しているオリジンと ACAO ヘッダーの値の不一致によりCORSエラーが起こる。（<code>target.com</code>が期待されているが、実際に提供されたのは<code>attacker.com</code> 。）以下に、この脆弱性を悪用して被害者のブラウザのキャッシュ状態を推測するコード例を示します。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#6272a4>// この関数は、単にURLを受け取り、CORS モードでfetchします。
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// fetchでエラーが発生した場合、attacker.comと犠牲者のIP間の
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// オリジンの不一致によるCORSエラーになります。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>function</span> ifCached(url) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// fetchエラーの場合はtrueを、
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// 成功の場合はfalseに解決するプロミスを返します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>return</span> fetch(url, {
</span></span><span style=display:flex><span>        mode<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;cors&#34;</span>
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .then(() =&gt; <span style=color:#ff79c6>false</span>)
</span></span><span style=display:flex><span>    .<span style=color:#ff79c6>catch</span>(() =&gt; <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// これは、server.comがorigin reflectionのCORS misconfigurationを
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 抱えていることを、攻撃者がすでに知っている場合にのみ有効。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> resource_url <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;server.com/reflected_origin_resource.html&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>var</span> verdict <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> ifCached(resource_url)
</span></span><span style=display:flex><span>console.log(<span style=color:#f1fa8c>&#34;Resource was cached: &#34;</span> <span style=color:#ff79c6>+</span> verdict)
</span></span></code></pre></div><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>これを軽減する最善の方法は、origin reflectionを排除して、 <code>Access-Control-Allow-Origin</code>ヘッダを使用することです。グローバルにアクセス可能で認証不要なリソースには <code>Access-Control-Allow-Origin: *</code> を使用します。</blockquote><h2 id=fetch-with-abortcontroller>Fetch with AbortController
<a class=anchor href=#fetch-with-abortcontroller>#</a></h2><p>以下のスニペットは、<a href=https://developer.mozilla.org/en-US/docs/Web/API/AbortController>AbortController</a>インターフェースを<em>fetch</em>と<em>setTimeout</em>と組み合わせることで、リソースがキャッシュされているかどうかを検出し、ブラウザのキャッシュから特定のリソースを退避させる方法を示しています。このテクニックの良いところは、その過程で新しいコンテンツをキャッシュすることなく、プローブが行われることです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#8be9fd;font-style:italic>function</span> ifCached(url, purge <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>) {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> controller <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> AbortController();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> signal <span style=color:#ff79c6>=</span> controller.signal;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// After 9ms, abort the request (before the request was finished).
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// The timeout might need to be adjusted for the attack to work properly.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// Purging content seems to take slightly less time than probing
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd;font-style:italic>var</span> wait_time <span style=color:#ff79c6>=</span> (purge) <span style=color:#ff79c6>?</span> <span style=color:#bd93f9>3</span> <span style=color:#ff79c6>:</span> <span style=color:#bd93f9>9</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> timeout <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> setTimeout(() =&gt; {
</span></span><span style=display:flex><span>        controller.abort();
</span></span><span style=display:flex><span>    }, wait_time);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// credentials option is needed for Firefox
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#8be9fd;font-style:italic>let</span> options <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>            mode<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;no-cors&#34;</span>,
</span></span><span style=display:flex><span>            credentials<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;include&#34;</span>,
</span></span><span style=display:flex><span>            signal<span style=color:#ff79c6>:</span> signal
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// If the option &#34;cache: reload&#34; is set, the browser will purge
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>// the resource from the browser cache
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span>(purge) options.cache <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;reload&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>await</span> fetch(url, options);
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>catch</span> (err) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// When controller.abort() is called, the fetch will throw an Exception
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span>(purge) console.log(<span style=color:#f1fa8c>&#34;The resource was purged from the cache&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> console.log(<span style=color:#f1fa8c>&#34;The resource is not cached&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// clearTimeout will only be called if this line was reached in less than
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// wait_time which means that the resource must have arrived from the cache
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    clearTimeout(timeout);
</span></span><span style=display:flex><span>    console.log(<span style=color:#f1fa8c>&#34;The resource is cached&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// purge https://example.org from the cache
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>await</span> ifCached(<span style=color:#f1fa8c>&#39;https://example.org&#39;</span>, <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Put https://example.org into the cache
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Skip this step to simulate a case where example.org is not cached
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>open(<span style=color:#f1fa8c>&#39;https://example.org&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// wait 1 second (until example.org loads)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>await</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd;font-style:italic>Promise</span>(resolve =&gt; setTimeout(resolve, <span style=color:#bd93f9>1000</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Check if https://example.org is in the cache
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>await</span> ifCached(<span style=color:#f1fa8c>&#39;https://example.org&#39;</span>);
</span></span></code></pre></div><h2 id=対策>対策
<a class=anchor href=#%e5%af%be%e7%ad%96>#</a></h2><p>現在、Cache Probing攻撃からウェブサイトを完全に保護できるような優れた防御メカニズムはありません。それでも、以下のような<a href=https://xsleaks.dev/docs/defenses/design-protections/cache-protections/>Cache Protections</a>を導入することで、Webサイトのattack surfaceを縮小することは可能です。</p><ul><li><a href=https://xsleaks.dev/docs/defenses/design-protections/cache-protections/#cache-protection-via-cache-control-headers>Cache-controlヘッダ</a>はリソースがキャッシュされるのを防ぐのに利用できます。</li><li><a href=https://xsleaks.dev/docs/defenses/design-protections/cache-protections/#cache-protection-via-random-tokens>Random Tokens</a>は攻撃者がURLを推測できないようにするために使用されます。</li><li><a href=https://xsleaks.dev/docs/defenses/design-protections/cache-protections/#cache-protection-via-fetch-metadata>Vary: Sec-Fetch-Site</a>はOriginのグループによってキャッシュを分離するために使用されます。</li><li>ネットワーク要求が可能なユーザーコンテンツは、キャッシュを分割できるように、別ドメインまたは公開サフィックスリスト（適用可能な場合）を使用して、独自のeTLD+1上に配置すべきである。</li></ul><p>キャッシュプロービング攻撃に対する有望な防御策は、要求元によってHTTPキャッシュを分割することです。このブラウザが提供する保護機能は、攻撃者のオリジンが他のオリジンのキャッシュされたリソースに干渉するのを防ぎます。</p><blockquote class="book-hint2 info"><p class="hint-title info"><svg class="book-icon"><use href="/svg/hint-icons.svg#info-notice"/></svg><span>info</span></p>2021年9月現在、eTLD+1ごとにキャッシュを分割するPartitioned Cachesは、ほとんどのブラウザで利用できますが、アプリケーションはこれに依存できない状況です。
サブドメインからのリクエストや<a href=https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass>window navigation</a>には保護が効きません。</blockquote><h2 id=リアルワールドでの例>リアルワールドでの例
<a class=anchor href=#%e3%83%aa%e3%82%a2%e3%83%ab%e3%83%af%e3%83%bc%e3%83%ab%e3%83%89%e3%81%a7%e3%81%ae%e4%be%8b>#</a></h2><p><a href=#cache-probing-with-error-events>Error Events Cache Probing</a>を利用した攻撃者は、ブラウザのキャッシュにビデオのサムネイルが残っているかどうかを確認することで、ユーザが特定のYouTubeビデオを視聴したかどうかを検出することができました<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>。</p><h2 id=参考文献>参考文献
<a class=anchor href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Timing Attacks on Web Privacy, <a href=http://www.cs.jhu.edu/~fabian/courses/CS600.424/course_papers/webtiming.pdf>link</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>HTTP Cache Cross-Site Leaks, <a href=http://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html>link</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>CORS misconfiguration, <a href=https://web-in-security.blogspot.com/2017/07/cors-misconfigurations-on-large-scale.html>link</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Mass XS-Search using Cache Attack, <a href=https://terjanq.github.io/Bug-Bounty/Google/cache-attack-06jd2d2mz2r0/index.html#VIII-YouTube-watching-history>link</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/xsleaks/wiki/commit/2e815f11bdac3b8d518bd367d1d1b91b39cd5a5b title='Last modified by 8ayac(Yoshinori Hayashi) | June 14, 2022' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>Last Modified: June 14, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/xsleaks/wiki/edit/master/content//docs/attacks/cache-probing.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this article</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#攻撃の原理>攻撃の原理</a></li><li><a href=#error-eventsによるcache-probing>Error EventsによるCache Probing</a><ul><li><a href=#キャッシュの無効化>キャッシュの無効化</a></li></ul></li><li><a href=#origin-reflectionによるcors-error>Origin ReflectionによるCORS error</a></li><li><a href=#fetch-with-abortcontroller>Fetch with AbortController</a></li><li><a href=#対策>対策</a></li><li><a href=#リアルワールドでの例>リアルワールドでの例</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></aside></main></body></html>