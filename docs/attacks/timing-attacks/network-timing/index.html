<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="ネットワーク タイミングのサイドチャネルは、ウェブが誕生したときから存在していました。これらの攻撃は、ブラウザがperformance.now()のような高精度のタイマーを出荷し始めたときに、新しい注目を集め、時とともに異なるレベルの影響を持つようになりました。
タイミング測定値を得るために、攻撃者は暗黙的または明示的なクロックを使用する必要があります。これらのクロックは、XS-Leaksの目的では通常交換可能であり、精度と利用可能性が異なるだけです。簡単のために、この記事では、すべてのモダンブラウザに存在する明示的なクロックであるperformance.now()APIを使用することを想定しています。
このサイドチャネルにより、攻撃者はクロスサイトリクエストが完了するまでにかかった時間から情報を推測することができます。ネットワークのタイミング測定は、ユーザーの状態によって変化する可能性があり、通常は下記の要素に連動します。
リソースサイズ バックエンドでの計算時間 サブリソースの数とサイズ キャッシュの状態. tip
クロックの種類については、クロックの記事で詳しく説明しています。 モダンなWebのタイミング攻撃 # performance.now()は、リクエストの実行にかかる時間を測定するために使用できます。
// クロックを開始します。 var start = performance.now() // fetchリクエストが完了するまでの時間を計測します。 fetch('https://example.org', { mode: 'no-cors', credentials: 'include' }).then(() => { // fetch終了した時点で時間差を計算します。 var time = performance.now() - start; console.log(&#34;The request took %d ms.&#34;, time); }); Onloadイベント # 同じような処理で、リソースを取得するのにかかる時間を測定するには、単に onload イベントを監視することで可能です。
// 時間が欲しいページを指すscript要素を作成します。 var script = document.createElement('script'); script.src = &#34;https://example.org&#34;; document.body.appendChild(script); // クロックを開始します。 var start = performance.now(); // スクリプトがロードされたら、リクエストが完了するまでの時間を計算します。 script.onload = () => { var time = performance."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Network Timing"><meta property="og:description" content="ネットワーク タイミングのサイドチャネルは、ウェブが誕生したときから存在していました。これらの攻撃は、ブラウザがperformance.now()のような高精度のタイマーを出荷し始めたときに、新しい注目を集め、時とともに異なるレベルの影響を持つようになりました。
タイミング測定値を得るために、攻撃者は暗黙的または明示的なクロックを使用する必要があります。これらのクロックは、XS-Leaksの目的では通常交換可能であり、精度と利用可能性が異なるだけです。簡単のために、この記事では、すべてのモダンブラウザに存在する明示的なクロックであるperformance.now()APIを使用することを想定しています。
このサイドチャネルにより、攻撃者はクロスサイトリクエストが完了するまでにかかった時間から情報を推測することができます。ネットワークのタイミング測定は、ユーザーの状態によって変化する可能性があり、通常は下記の要素に連動します。
リソースサイズ バックエンドでの計算時間 サブリソースの数とサイズ キャッシュの状態. tip
クロックの種類については、クロックの記事で詳しく説明しています。 モダンなWebのタイミング攻撃 # performance.now()は、リクエストの実行にかかる時間を測定するために使用できます。
// クロックを開始します。 var start = performance.now() // fetchリクエストが完了するまでの時間を計測します。 fetch('https://example.org', { mode: 'no-cors', credentials: 'include' }).then(() => { // fetch終了した時点で時間差を計算します。 var time = performance.now() - start; console.log(&#34;The request took %d ms.&#34;, time); }); Onloadイベント # 同じような処理で、リソースを取得するのにかかる時間を測定するには、単に onload イベントを監視することで可能です。
// 時間が欲しいページを指すscript要素を作成します。 var script = document.createElement('script'); script.src = &#34;https://example.org&#34;; document.body.appendChild(script); // クロックを開始します。 var start = performance.now(); // スクリプトがロードされたら、リクエストが完了するまでの時間を計算します。 script.onload = () => { var time = performance."><meta property="og:type" content="article"><meta property="og:url" content="https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/network-timing/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2020-10-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-31T09:11:56-07:00"><title>Network Timing | XS-Leaks Wiki</title><link rel=manifest href=/xs-leaks/manifest.json><link rel=icon href=/xs-leaks/favicon.png type=image/x-icon><link rel=stylesheet href=/xs-leaks/book.min.1c9a9009be3c645cbccbe64eb0a90e28621e4118971d9a502db4aaa9bec96cfc.css integrity="sha256-HJqQCb48ZFy8y+ZOsKkOKGIeQRiXHZpQLbSqqb7JbPw="><script defer src=/xs-leaks/en.search.min.3f4d86752e03bee26096d0706d69248797644a7e5ae2f27bd2401b47568d3779.js integrity="sha256-P02GdS4DvuJgltBwbWkkh5dkSn5a4vJ70kAbR1aNN3k="></script>
<script defer src=/xs-leaks/sw.min.8fe20fa5c13f563a054a6d30584266c3ce999873dcc8c0008902c3c633a2d1b0.js integrity="sha256-j+IPpcE/VjoFSm0wWEJmw86ZmHPcyMAAiQLDxjOi0bA="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/xs-leaks><span>XS-Leaks Wiki</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>攻撃手法</span><ul><li><a href=/xs-leaks/docs/attacks/xs-search/>XS-Search</a></li><li><a href=/xs-leaks/docs/attacks/window-references/>Window References</a></li><li><a href=/xs-leaks/docs/attacks/css-tricks/>CSS Tricks</a></li><li><a href=/xs-leaks/docs/attacks/error-events/>Error Events</a></li><li><a href=/xs-leaks/docs/attacks/frame-counting/>Frame Counting</a></li><li><a href=/xs-leaks/docs/attacks/navigations/>Navigations</a></li><li><a href=/xs-leaks/docs/attacks/cache-probing/>Cache Probing</a></li><li><a href=/xs-leaks/docs/attacks/element-leaks/>Element leaks</a></li><li><a href=/xs-leaks/docs/attacks/id-attribute/>ID Attribute</a></li><li><a href=/xs-leaks/docs/attacks/postmessage-broadcasts/>postMessage Broadcasts</a></li><li><span>Browser Features</span><ul><li><a href=/xs-leaks/docs/attacks/browser-features/corb/>CORB Leaks</a></li><li><a href=/xs-leaks/docs/attacks/browser-features/corp/>CORP Leaks</a></li></ul></li><li><span>Timing Attacks</span><ul><li><a href=/xs-leaks/docs/attacks/timing-attacks/clocks/>Clocks</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/network-timing/ class=active>Network Timing</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/performance-api/>Performance API</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/execution-timing/>Execution Timing</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/hybrid-timing/>Hybrid Timing</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/connection-pool/>Connection Pool</a></li></ul></li><li><a href=/xs-leaks/docs/attacks/experiments/ class=collapsed>Experiments</a></li><li><a href=/xs-leaks/docs/attacks/css-injection/>CSS Injection</a></li><li><a href=/xs-leaks/docs/attacks/historical/ class=collapsed>Historical</a></li></ul></li><li class=book-section-flat><a href=/xs-leaks/docs/defenses/>対策の仕組み</a><ul><li><a href=/xs-leaks/docs/defenses/design-protections/>Application Design</a><ul><li><a href=/xs-leaks/docs/defenses/design-protections/cache-protections/>Cache Protections</a></li><li><a href=/xs-leaks/docs/defenses/design-protections/subresource-protections/>Subresource Protections</a></li></ul></li><li><a href=/xs-leaks/docs/defenses/opt-in/>Opt-In Mechanisms</a><ul><li><a href=/xs-leaks/docs/defenses/opt-in/fetch-metadata/>Fetch Metadata</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/coop/>Cross-Origin-Opener-Policy</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/corp/>Cross-Origin-Resource-Policy</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/xfo/>Framing Protections</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/same-site-cookies/>SameSite Cookies</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/document-policies/>Document Policies</a></li></ul></li><li><a href=/xs-leaks/docs/defenses/isolation-policies/>Isolation Policies</a><ul><li><a href=/xs-leaks/docs/defenses/isolation-policies/resource-isolation/>Resource Isolation Policy</a></li><li><a href=/xs-leaks/docs/defenses/isolation-policies/framing-isolation/>Framing Isolation Policy</a></li><li><a href=/xs-leaks/docs/defenses/isolation-policies/navigation-isolation/>Navigation Isolation Policy</a></li><li><a href=/xs-leaks/docs/defenses/isolation-policies/strict-isolation/>Strict Isolation Policy</a></li></ul></li><li><a href=/xs-leaks/docs/defenses/secure-defaults/>Secure Defaults</a><ul><li><a href=/xs-leaks/docs/defenses/secure-defaults/corb/>Cross-Origin Read Blocking</a></li><li><a href=/xs-leaks/docs/defenses/secure-defaults/partitioned-cache/>Partitioned HTTP Cache</a></li></ul></li></ul></li><li class=book-section-flat><a href=/xs-leaks/docs/contributions/>Contributions</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/xs-leaks/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Network Timing</strong>
<label for=toc-control><img src=/xs-leaks/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#モダンなwebのタイミング攻撃>モダンなWebのタイミング攻撃</a></li><li><a href=#onloadイベント>Onloadイベント</a></li><li><a href=#cross-windowなタイミング攻撃>Cross-windowなタイミング攻撃</a></li><li><a href=#イベントのアンロード>イベントのアンロード</a></li><li><a href=#サンドボックス化されたフレームのタイミング攻撃>サンドボックス化されたフレームのタイミング攻撃</a></li><li><a href=#タイムレスタイミング攻撃>タイムレスタイミング攻撃</a></li><li><a href=#対策>対策</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></aside></header><article class=markdown><h1>Network Timing</h1><h5>October 1, 2020</h5><div>Abuse
<a href=/xs-leaks/abuse/iframes/>iframes</a></div><div>Category
<a href=/xs-leaks/category/attack/>Attack</a></div><div>Defenses
<a href=/xs-leaks/defenses/fetch-metadata/>Fetch Metadata</a>,
<a href=/xs-leaks/defenses/samesite-cookies/>SameSite Cookies</a>,
<a href=/xs-leaks/defenses/coop/>COOP</a>,
<a href=/xs-leaks/defenses/framing-protections/>Framing Protections</a></div><p><p>ネットワーク タイミングのサイドチャネルは、ウェブが誕生したときから存在していました。これらの攻撃は、ブラウザが<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/clocks/#performancenow>performance.now()</a>のような高精度のタイマーを出荷し始めたときに、新しい注目を集め、時とともに異なるレベルの影響を持つようになりました。</p><p>タイミング測定値を得るために、攻撃者は暗黙的または明示的なクロックを使用する必要があります。これらの<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/clocks/>クロック</a>は、XS-Leaksの目的では通常交換可能であり、精度と利用可能性が異なるだけです。簡単のために、この記事では、すべてのモダンブラウザに存在する明示的なクロックである<code>performance.now()</code>APIを使用することを想定しています。</p><p>このサイドチャネルにより、攻撃者はクロスサイトリクエストが完了するまでにかかった時間から情報を推測することができます。ネットワークのタイミング測定は、ユーザーの状態によって変化する可能性があり、通常は下記の要素に連動します。</p><ul><li>リソースサイズ</li><li>バックエンドでの計算時間</li><li>サブリソースの数とサイズ</li><li><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/cache-probing/>キャッシュの状態</a>.</li></ul><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>クロックの種類については、<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/clocks/>クロックの記事</a>で詳しく説明しています。</blockquote><h2 id=モダンなwebのタイミング攻撃>モダンなWebのタイミング攻撃
<a class=anchor href=#%e3%83%a2%e3%83%80%e3%83%b3%e3%81%aaweb%e3%81%ae%e3%82%bf%e3%82%a4%e3%83%9f%e3%83%b3%e3%82%b0%e6%94%bb%e6%92%83>#</a></h2><p><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/clocks/#performancenow>performance.now()</a>は、リクエストの実行にかかる時間を測定するために使用できます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#6272a4>// クロックを開始します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> start <span style=color:#ff79c6>=</span> performance.now()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// fetchリクエストが完了するまでの時間を計測します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>fetch(<span style=color:#f1fa8c>&#39;https://example.org&#39;</span>, {
</span></span><span style=display:flex><span>  mode<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;no-cors&#39;</span>,
</span></span><span style=display:flex><span>  credentials<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#39;include&#39;</span>
</span></span><span style=display:flex><span>}).then(() =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// fetch終了した時点で時間差を計算します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#8be9fd;font-style:italic>var</span> time <span style=color:#ff79c6>=</span> performance.now() <span style=color:#ff79c6>-</span> start;
</span></span><span style=display:flex><span>  console.log(<span style=color:#f1fa8c>&#34;The request took %d ms.&#34;</span>, time);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=onloadイベント>Onloadイベント
<a class=anchor href=#onload%e3%82%a4%e3%83%99%e3%83%b3%e3%83%88>#</a></h2><p>同じような処理で、リソースを取得するのにかかる時間を測定するには、単に <code>onload</code> イベントを監視することで可能です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#6272a4>// 時間が欲しいページを指すscript要素を作成します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> script <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.createElement(<span style=color:#f1fa8c>&#39;script&#39;</span>);
</span></span><span style=display:flex><span>script.src <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;https://example.org&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>document</span>.body.appendChild(script);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// クロックを開始します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> start <span style=color:#ff79c6>=</span> performance.now();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// スクリプトがロードされたら、リクエストが完了するまでの時間を計算します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>script.onload <span style=color:#ff79c6>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>var</span> time <span style=color:#ff79c6>=</span> performance.now() <span style=color:#ff79c6>-</span> start;
</span></span><span style=display:flex><span>  console.log(<span style=color:#f1fa8c>&#34;The request took %d ms.&#34;</span>, time)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>同様の手法は他の HTML 要素、例えば <code>&lt;img></code>, <code>&lt;link></code>, <code>&lt;iframe></code> にも使うことができ、他の手法が失敗するシナリオで使用することができます。例えば、<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/fetch-metadata/>Fetch Metadata</a>が script タグへのリソースの読み込みをブロックする場合、image タグへの読み込みを許可することがあります。</blockquote><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>別の方法として、<code>image.complete</code>プロパティを使用することもできます。詳しくは<a href=https://riccardomerlano.github.io/xs-leaks/cache-probing-through-image.complete-property/>こちら</a></blockquote></p><h2 id=cross-windowなタイミング攻撃>Cross-windowなタイミング攻撃
<a class=anchor href=#cross-window%e3%81%aa%e3%82%bf%e3%82%a4%e3%83%9f%e3%83%b3%e3%82%b0%e6%94%bb%e6%92%83>#</a></h2><p>攻撃者は、<code>window.open</code>で新しいウィンドウを開き、<code>window</code>の読み込みが始まるのを待つことで、ページのネットワークタイミングを測定することも可能です。以下のスニペットは、この測定の方法を示しています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#6272a4>// 新しいウィンドウを開き、iframeの読み込みを開始するタイミングを測定します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> win <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>window</span>.open(<span style=color:#f1fa8c>&#39;https://example.org&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 最初の時間を計測します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> start <span style=color:#ff79c6>=</span> performance.now();
</span></span><span style=display:flex><span><span style=color:#6272a4>// ループを定義します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>function</span> measure(){
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>try</span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ページがロードされた場合、そのページは異なるオリジンになるので、
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// `win.origin`は例外をスローします。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    win.origin;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ウィンドウがsame-originのままであれば、すぐにループを繰り返しますが、
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// イベントループはブロックしません。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    setTimeout(measure, <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>  }<span style=color:#ff79c6>catch</span>(e){
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ウィンドウが読み込まれたら、時間差を計算します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd;font-style:italic>var</span> time <span style=color:#ff79c6>=</span> performance.now() <span style=color:#ff79c6>-</span> start;
</span></span><span style=display:flex><span>    console.log(<span style=color:#f1fa8c>&#39;It took %d ms to load the window&#39;</span>, time);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// ウィンドウのオリジンが切り替わった時点で抜けるループを開始する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>measure();
</span></span></code></pre></div><p><blockquote class="book-hint2 note"><p class="hint-title note"><svg class="book-icon"><use href="/svg/hint-icons.svg#note-notice"/></svg><span>note</span></p>このPOCでは<code>setTimeout</code>を使って、 <code>while(true)</code>ループに相当する部分を大まかに作成していることに注意してください。JSのイベントループがブロックされるのを避けるために、このような方法で実装する必要があります。</blockquote><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>この手法は、<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/execution-timing/#busy-event-loop>イベントループをビジー状態にする</a>ことで、ページの実行タイミングを測定することにも応用できます。</blockquote></p><h2 id=イベントのアンロード>イベントのアンロード
<a class=anchor href=#%e3%82%a4%e3%83%99%e3%83%b3%e3%83%88%e3%81%ae%e3%82%a2%e3%83%b3%e3%83%ad%e3%83%bc%e3%83%89>#</a></h2><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event><code>unload</code></a>と<a href=https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event><code>beforeunload</code></a>イベントは、リソースを取得するのにかかる時間を測定するために使用することができます。これは、ブラウザが新しいナビゲーションを要求したときに<code>beforeunload</code>がトリガーされ、一方、そのナビゲーションが実際に発生したときにunloadがトリガーされるためです。この動作により、これら2つのイベント間の時間差を計算し、ブラウザがリソースの取得を完了するまでにかかった時間を測定することが可能です。</p><blockquote class="book-hint2 info"><p class="hint-title info"><svg class="book-icon"><use href="/svg/hint-icons.svg#info-notice"/></svg><span>info</span></p><code>unload</code>と<code>beforeunload</code>の時間差は<code>x-frame-options</code> (XFO)ヘッダーの影響を受けません。なぜなら、このイベントはブラウザがレスポンスヘッダーを認識する前に起動されるからです。</blockquote><p>以下のスニペットでは、<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers>SharedArrayBufferクロック</a>を使用していますが、このスニペットを実行する前に、クロックを開始する必要があります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#6272a4>// WebWorkerが使用するShared bufferの作成
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> sharedBuffer <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> SharedArrayBuffer(Uint32Array.BYTES_PER_ELEMENT);
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>var</span> sharedArray <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> Uint32Array(sharedBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// WebWorkerを起動し、呼び出します。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>worker.postMessage(sharedBuffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>var</span> start;
</span></span><span style=display:flex><span>iframe.contentWindow.onbeforeunload <span style=color:#ff79c6>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// ナビゲーション中の「時間」を取得します
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  start <span style=color:#ff79c6>=</span> Atomics.load(sharedArray, <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>iframe.contentWindow.onpagehide <span style=color:#ff79c6>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// ナビゲーション後の「時間」を取得します
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#8be9fd;font-style:italic>var</span> end <span style=color:#ff79c6>=</span> Atomics.load(sharedArray, <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>  console.log(<span style=color:#f1fa8c>&#39;The difference between events was %d iterations&#39;</span>, end <span style=color:#ff79c6>-</span> start);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers>SharedArrayBufferのクロック</a>は高解像度のタイマーを作成するために使用されました。しかし、iframeの <code>beforeunload</code> と <code>unload</code> イベント間の時間差は、他のクロック、例えば*performance.now()*でも測定できます。</blockquote><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>このスニペットでは、iframeを利用して計測しています。この攻撃のバリエーションは、ウィンドウの参照を使用することもできますが、これに対する防御はより困難です。</blockquote></p><h2 id=サンドボックス化されたフレームのタイミング攻撃>サンドボックス化されたフレームのタイミング攻撃
<a class=anchor href=#%e3%82%b5%e3%83%b3%e3%83%89%e3%83%9c%e3%83%83%e3%82%af%e3%82%b9%e5%8c%96%e3%81%95%e3%82%8c%e3%81%9f%e3%83%95%e3%83%ac%e3%83%bc%e3%83%a0%e3%81%ae%e3%82%bf%e3%82%a4%e3%83%9f%e3%83%b3%e3%82%b0%e6%94%bb%e6%92%83>#</a></h2><p>もしページに<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/xfo/>Framing Protections</a>が実装されていなければ、攻撃者はページとすべてのサブリソースがネットワーク上でロードされるまでの時間を計ることができます。デフォルトでは、iframeの <code>onload</code> ハンドラはすべてのリソースがロードされ、すべてのJavaScriptの実行が終了した後に呼び出されます。しかし、攻撃者は <code>&lt;iframe></code> に <code>sandbox</code> 属性を含めることで、スクリプト実行時のノイズを除去することができます。この属性はJavaScriptの実行を含む多くの機能をブロックし、その結果、ほとんど純粋なネットワーク計測を行うことができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>var</span> iframe <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.createElement(<span style=color:#f1fa8c>&#39;iframe&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 対象のWebサイトのURLを設定する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>iframe.src <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;https://example.org&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#6272a4>// スクリプトの実行をブロックするsandbox属性を設定する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>iframe.sandbox <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>document</span>.body.appendChild(iframe);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 要求が開始されるまでの時間を測定する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> start <span style=color:#ff79c6>=</span> performance.now();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>iframe.onload <span style=color:#ff79c6>=</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// iframeが読み込まれたら、時間差を計算する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#8be9fd;font-style:italic>var</span> time <span style=color:#ff79c6>=</span> performance.now() <span style=color:#ff79c6>-</span> start;
</span></span><span style=display:flex><span>  console.log(<span style=color:#f1fa8c>&#34;The iframe and subresources took %d ms to load.&#34;</span>, time)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=タイムレスタイミング攻撃>タイムレスタイミング攻撃
<a class=anchor href=#%e3%82%bf%e3%82%a4%e3%83%a0%e3%83%ac%e3%82%b9%e3%82%bf%e3%82%a4%e3%83%9f%e3%83%b3%e3%82%b0%e6%94%bb%e6%92%83>#</a></h2><p>この他に、タイミング攻撃を実行するために時間の概念を考慮しないタイプの攻撃もあります。このタイムレス攻撃は、2つのHTTPリクエスト(baseline request及びattacked request)を1つのパケットにまとめ、それらをサーバーに同時に到着させることで成立します。サーバーはリクエストを同時に処理し、その実行時間に基づいたレスポンスを可能な限り最速で返します。2つのリクエストのうちどちらかが先に到着することになり、攻撃者はリクエストの到着順序を比較することで時間差を推測することができます。</p><p>この手法の利点は、他の手法では常に存在する、ネットワークのジッターや不確定な遅延から独立していることです。</p><p>この攻撃は HTTP の特定のバージョンと共同シナリオに限定されます。それは特定の仮定をし、サーバーの動作に関する要件を持っています。</p><p>他のタイプの攻撃は、タイミング攻撃を実行する時間の概念を考慮しません <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。
タイムレスな攻撃は、2 つの「HTTP」リクエスト (ベースラインと攻撃リクエスト) を 1 つのパケットに合わせて、サーバーに同時に到着することを保証することで構成されます。 サーバーはリクエストを同時に処理し、<em>できるだけ早く</em>実行時間に基づいて応答を返します。 2 つのリクエストのうちの 1 つが最初に到着するため、攻撃者はリクエストが到着した順序を比較することで時間差を推測できます。</p><p>この手法の利点は、ネットワークのジッターや不確実な遅延から独立していることです。これは、残りの手法に常に存在するものです。</p><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p>この攻撃は、HTTPの特定のバージョンと共同シナリオに限定されています。特定の前提や、サーバの動作に関して満たさなくてはならないことがあります。</blockquote><h2 id=対策>対策
<a class=anchor href=#%e5%af%be%e7%ad%96>#</a></h2><table><thead><tr><th style=text-align:center>Attack Alternative</th><th style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/same-site-cookies/>SameSite Cookies (Lax)</a></th><th style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/coop/>COOP</a></th><th style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/xfo/>Framing Protections</a></th><th style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/>Isolation Policies</a></th></tr></thead><tbody><tr><td style=text-align:center>Modern Timing Attacks</td><td style=text-align:center>✔️</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/resource-isolation/>RIP</a> 🔗 <a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/navigation-isolation/>NIP</a></td></tr><tr><td style=text-align:center>Frame Timing (Network)</td><td style=text-align:center>✔️</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/framing-isolation/>FIP</a></td></tr><tr><td style=text-align:center>Frame Timing (Sandbox)</td><td style=text-align:center>✔️</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/framing-isolation/>FIP</a></td></tr><tr><td style=text-align:center>Cross-window Timing</td><td style=text-align:center>❌</td><td style=text-align:center>✔️</td><td style=text-align:center>❌</td><td style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/navigation-isolation/>NIP</a></td></tr><tr><td style=text-align:center>Timeless Timing</td><td style=text-align:center>✔️</td><td style=text-align:center>✔️</td><td style=text-align:center>❌</td><td style=text-align:center>❓</td></tr></tbody></table><p>🔗 – Defense mechanisms must be combined to be effective against different scenarios.</p><h2 id=参考文献>参考文献
<a class=anchor href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Timeless Timing Attacks: Exploiting Concurrency to Leak Secrets over Remote Connections, <a href=https://www.usenix.org/system/files/sec20-van_goethem.pdf>link</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/WebAppPentestGuidelines/xs-leaks//commit/acbdb2b9976df1a17987799e6cc146504a6f2cdf title='Last modified by root | August 31, 2022' target=_blank rel=noopener><img src=/xs-leaks/svg/calendar.svg class=book-icon alt=Calendar>
<span>Last Modified: August 31, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/WebAppPentestGuidelines/xs-leaks//edit/master/content//docs/attacks/timing-attacks/network-timing.md target=_blank rel=noopener><img src=/xs-leaks/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this article</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#モダンなwebのタイミング攻撃>モダンなWebのタイミング攻撃</a></li><li><a href=#onloadイベント>Onloadイベント</a></li><li><a href=#cross-windowなタイミング攻撃>Cross-windowなタイミング攻撃</a></li><li><a href=#イベントのアンロード>イベントのアンロード</a></li><li><a href=#サンドボックス化されたフレームのタイミング攻撃>サンドボックス化されたフレームのタイミング攻撃</a></li><li><a href=#タイムレスタイミング攻撃>タイムレスタイミング攻撃</a></li><li><a href=#対策>対策</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></aside></main></body></html>