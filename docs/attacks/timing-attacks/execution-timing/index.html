<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="ブラウザ上でのJavaScriptの実行時間を測定することで、攻撃者は特定のイベントがいつ発生したか、ある操作にどれくらいの時間がかかったかといった情報を得ることができます。
イベントループのタイミング # JavaScriptの並行処理モデルは、single-threaded event loopに基づいており、これは一度に一つのタスクしか実行できないことを意味します。 例えば、ある時間のかかるタスクがイベントループをブロックした場合、UIスレッドが枯渇した結果として、ユーザーはページがフリーズしたように感じることがあります。 他のタスクはブロックされたタスクが終了するまで待たなければなりません。 各ブラウザは異なるプロセスモデルを実装しているので、ウェブサイトによっては、その関係によって異なるスレッド（およびイベントループ）で実行されることがあります。
このモデルを悪用して、クロスオリジンページから秘密を盗みだす手法があります。
イベントプールで次に実行されるまでの時間を測定することで、異なるオリジンのコードが実行されるまでの時間を推測する。攻撃者は固定されたプロパティを持つイベントをイベントループ12に送り続け、プールが空になると最終的にディスパッチされます。他のオリジンは同じプールにイベントをディスパッチし、ここで攻撃者はそのタスクの一つで遅延が発生したかどうかを検出することで、時間差を推測します。 攻撃者が制御する文字列によって前記の機密情報が比較される場合、クロスオリジンページから機密情報を盗む。このリークは、1文字ずつの文字列比較2のイベントループで時間差を比較した結果です（前出の手法を使用）。process isolationを行わないブラウザでは、異なるオリジン間のクロスウィンドウ通信が同じスレッドで実行され、同じイベントループを共有します。 important
process isolationの仕組みがあるブラウザでは、後者の攻撃の可能性はすでにありません。このような仕組みは、現在Chromiumベースのブラウザでは Site Isolationのみで、Firefox にはProject Fission という名前で間もなく導入される予定です。 Busy Event Loop # 別の手法として、スレッドのイベントループをブロックし、イベントループが再び利用可能になるまでの時間を計測する方法があります。 この手法の主な利点の1つは、攻撃者のオリジンが他のオリジンの実行に影響を与えることができるため、Site Isolationを回避できることです。この攻撃は次のように動作します。
対象のウェブサイトをwindow.openで別ウィンドウに表示するか、iframe内に表示する。(Framing Protectionsが設定されていない場合) 長い計算が始まるのを待つ。 Framing Protectionsに関係なく、同じサイトのページをiframe内に読み込む 攻撃者は、(手順3の)iframeがonloadイベントをトリガーするのにかかった時間を計ることで、ターゲットのウェブサイトが実行された時間を検出できます。(Network Timing of step 3 should be minimal) 両方のナビゲーションは同じコンテキストで発生し、それらは同じサイトであるため、同じスレッドで実行され、同じイベントループを共有します。（それらは互いにブロックすることができます。）
// 新しいウィンドウを開いて、example.comのイベントループを // ウィンドウがブロックする時間を測定する window.open('https://example.org/expensive'); // TODO: タイムアウトなどでコストの掛かるウィンドウがロードされるのを待ちます。 var ifr = document.createElement('iframe'); ifr.src = &#34;https://example.org&#34;; document.body.appendChild(ifr); // 初期時間の測定 var start = performance.now(); ifr.onload = () => { // iframeが読み込まれたら、時間差を計算する var time = performance."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Execution Timing"><meta property="og:description" content="ブラウザ上でのJavaScriptの実行時間を測定することで、攻撃者は特定のイベントがいつ発生したか、ある操作にどれくらいの時間がかかったかといった情報を得ることができます。
イベントループのタイミング # JavaScriptの並行処理モデルは、single-threaded event loopに基づいており、これは一度に一つのタスクしか実行できないことを意味します。 例えば、ある時間のかかるタスクがイベントループをブロックした場合、UIスレッドが枯渇した結果として、ユーザーはページがフリーズしたように感じることがあります。 他のタスクはブロックされたタスクが終了するまで待たなければなりません。 各ブラウザは異なるプロセスモデルを実装しているので、ウェブサイトによっては、その関係によって異なるスレッド（およびイベントループ）で実行されることがあります。
このモデルを悪用して、クロスオリジンページから秘密を盗みだす手法があります。
イベントプールで次に実行されるまでの時間を測定することで、異なるオリジンのコードが実行されるまでの時間を推測する。攻撃者は固定されたプロパティを持つイベントをイベントループ12に送り続け、プールが空になると最終的にディスパッチされます。他のオリジンは同じプールにイベントをディスパッチし、ここで攻撃者はそのタスクの一つで遅延が発生したかどうかを検出することで、時間差を推測します。 攻撃者が制御する文字列によって前記の機密情報が比較される場合、クロスオリジンページから機密情報を盗む。このリークは、1文字ずつの文字列比較2のイベントループで時間差を比較した結果です（前出の手法を使用）。process isolationを行わないブラウザでは、異なるオリジン間のクロスウィンドウ通信が同じスレッドで実行され、同じイベントループを共有します。 important
process isolationの仕組みがあるブラウザでは、後者の攻撃の可能性はすでにありません。このような仕組みは、現在Chromiumベースのブラウザでは Site Isolationのみで、Firefox にはProject Fission という名前で間もなく導入される予定です。 Busy Event Loop # 別の手法として、スレッドのイベントループをブロックし、イベントループが再び利用可能になるまでの時間を計測する方法があります。 この手法の主な利点の1つは、攻撃者のオリジンが他のオリジンの実行に影響を与えることができるため、Site Isolationを回避できることです。この攻撃は次のように動作します。
対象のウェブサイトをwindow.openで別ウィンドウに表示するか、iframe内に表示する。(Framing Protectionsが設定されていない場合) 長い計算が始まるのを待つ。 Framing Protectionsに関係なく、同じサイトのページをiframe内に読み込む 攻撃者は、(手順3の)iframeがonloadイベントをトリガーするのにかかった時間を計ることで、ターゲットのウェブサイトが実行された時間を検出できます。(Network Timing of step 3 should be minimal) 両方のナビゲーションは同じコンテキストで発生し、それらは同じサイトであるため、同じスレッドで実行され、同じイベントループを共有します。（それらは互いにブロックすることができます。）
// 新しいウィンドウを開いて、example.comのイベントループを // ウィンドウがブロックする時間を測定する window.open('https://example.org/expensive'); // TODO: タイムアウトなどでコストの掛かるウィンドウがロードされるのを待ちます。 var ifr = document.createElement('iframe'); ifr.src = &#34;https://example.org&#34;; document.body.appendChild(ifr); // 初期時間の測定 var start = performance.now(); ifr.onload = () => { // iframeが読み込まれたら、時間差を計算する var time = performance."><meta property="og:type" content="article"><meta property="og:url" content="https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/execution-timing/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2020-10-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-31T09:11:56-07:00"><title>Execution Timing | XS-Leaks Wiki</title><link rel=manifest href=/xs-leaks/manifest.json><link rel=icon href=/xs-leaks/favicon.png type=image/x-icon><link rel=stylesheet href=/xs-leaks/book.min.1c9a9009be3c645cbccbe64eb0a90e28621e4118971d9a502db4aaa9bec96cfc.css integrity="sha256-HJqQCb48ZFy8y+ZOsKkOKGIeQRiXHZpQLbSqqb7JbPw="><script defer src=/xs-leaks/en.search.min.3f4d86752e03bee26096d0706d69248797644a7e5ae2f27bd2401b47568d3779.js integrity="sha256-P02GdS4DvuJgltBwbWkkh5dkSn5a4vJ70kAbR1aNN3k="></script>
<script defer src=/xs-leaks/sw.min.8fe20fa5c13f563a054a6d30584266c3ce999873dcc8c0008902c3c633a2d1b0.js integrity="sha256-j+IPpcE/VjoFSm0wWEJmw86ZmHPcyMAAiQLDxjOi0bA="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/xs-leaks><span>XS-Leaks Wiki</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>攻撃手法</span><ul><li><a href=/xs-leaks/docs/attacks/xs-search/>XS-Search</a></li><li><a href=/xs-leaks/docs/attacks/window-references/>Window References</a></li><li><a href=/xs-leaks/docs/attacks/css-tricks/>CSS Tricks</a></li><li><a href=/xs-leaks/docs/attacks/error-events/>Error Events</a></li><li><a href=/xs-leaks/docs/attacks/frame-counting/>Frame Counting</a></li><li><a href=/xs-leaks/docs/attacks/navigations/>Navigations</a></li><li><a href=/xs-leaks/docs/attacks/cache-probing/>Cache Probing</a></li><li><a href=/xs-leaks/docs/attacks/element-leaks/>Element leaks</a></li><li><a href=/xs-leaks/docs/attacks/id-attribute/>ID Attribute</a></li><li><a href=/xs-leaks/docs/attacks/postmessage-broadcasts/>postMessage Broadcasts</a></li><li><span>Browser Features</span><ul><li><a href=/xs-leaks/docs/attacks/browser-features/corb/>CORB Leaks</a></li><li><a href=/xs-leaks/docs/attacks/browser-features/corp/>CORP Leaks</a></li></ul></li><li><span>Timing Attacks</span><ul><li><a href=/xs-leaks/docs/attacks/timing-attacks/clocks/>Clocks</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/network-timing/>Network Timing</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/performance-api/>Performance API</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/execution-timing/ class=active>Execution Timing</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/hybrid-timing/>Hybrid Timing</a></li><li><a href=/xs-leaks/docs/attacks/timing-attacks/connection-pool/>Connection Pool</a></li></ul></li><li><a href=/xs-leaks/docs/attacks/experiments/ class=collapsed>Experiments</a></li><li><a href=/xs-leaks/docs/attacks/css-injection/>CSS Injection</a></li><li><a href=/xs-leaks/docs/attacks/historical/ class=collapsed>Historical</a></li></ul></li><li class=book-section-flat><a href=/xs-leaks/docs/defenses/>対策の仕組み</a><ul><li><a href=/xs-leaks/docs/defenses/design-protections/>Application Design</a><ul><li><a href=/xs-leaks/docs/defenses/design-protections/cache-protections/>Cache Protections</a></li><li><a href=/xs-leaks/docs/defenses/design-protections/subresource-protections/>Subresource Protections</a></li></ul></li><li><a href=/xs-leaks/docs/defenses/opt-in/>Opt-In Mechanisms</a><ul><li><a href=/xs-leaks/docs/defenses/opt-in/fetch-metadata/>Fetch Metadata</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/coop/>Cross-Origin-Opener-Policy</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/corp/>Cross-Origin-Resource-Policy</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/xfo/>Framing Protections</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/same-site-cookies/>SameSite Cookies</a></li><li><a href=/xs-leaks/docs/defenses/opt-in/document-policies/>Document Policies</a></li></ul></li><li><a href=/xs-leaks/docs/defenses/isolation-policies/>Isolation Policies</a><ul><li><a href=/xs-leaks/docs/defenses/isolation-policies/resource-isolation/>Resource Isolation Policy</a></li><li><a href=/xs-leaks/docs/defenses/isolation-policies/framing-isolation/>Framing Isolation Policy</a></li><li><a href=/xs-leaks/docs/defenses/isolation-policies/navigation-isolation/>Navigation Isolation Policy</a></li><li><a href=/xs-leaks/docs/defenses/isolation-policies/strict-isolation/>Strict Isolation Policy</a></li></ul></li><li><a href=/xs-leaks/docs/defenses/secure-defaults/>Secure Defaults</a><ul><li><a href=/xs-leaks/docs/defenses/secure-defaults/corb/>Cross-Origin Read Blocking</a></li><li><a href=/xs-leaks/docs/defenses/secure-defaults/partitioned-cache/>Partitioned HTTP Cache</a></li></ul></li></ul></li><li class=book-section-flat><a href=/xs-leaks/docs/contributions/>Contributions</a><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/xs-leaks/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Execution Timing</strong>
<label for=toc-control><img src=/xs-leaks/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#イベントループのタイミング>イベントループのタイミング</a></li><li><a href=#busy-event-loop>Busy Event Loop</a></li><li><a href=#サービスワーカー>サービスワーカー</a><ul><li><a href=#jquerycssセレクタそしてshort-circuit-timing>jQuery、CSSセレクタ、そしてShort-circuit Timing</a></li></ul></li><li><a href=#redos>ReDoS</a></li><li><a href=#対策>対策</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></aside></header><article class=markdown><h1>Execution Timing</h1><h5>October 1, 2020</h5><div>Abuse
<a href=/xs-leaks/abuse/event-loop/>Event Loop</a>,
<a href=/xs-leaks/abuse/service-workers/>Service Workers</a>,
<a href=/xs-leaks/abuse/site-isolation/>Site Isolation</a>,
<a href=/xs-leaks/abuse/css-injections/>CSS Injections</a>,
<a href=/xs-leaks/abuse/regex-injections/>Regex Injections</a>,
<a href=/xs-leaks/abuse/iframes/>iframes</a></div><div>Category
<a href=/xs-leaks/category/attack/>Attack</a></div><div>Defenses
<a href=/xs-leaks/defenses/fetch-metadata/>Fetch Metadata</a>,
<a href=/xs-leaks/defenses/samesite-cookies/>SameSite Cookies</a>,
<a href=/xs-leaks/defenses/coop/>COOP</a>,
<a href=/xs-leaks/defenses/framing-protections/>Framing Protections</a></div><p><p>ブラウザ上でのJavaScriptの実行時間を測定することで、攻撃者は特定のイベントがいつ発生したか、ある操作にどれくらいの時間がかかったかといった情報を得ることができます。</p><h2 id=イベントループのタイミング>イベントループのタイミング
<a class=anchor href=#%e3%82%a4%e3%83%99%e3%83%b3%e3%83%88%e3%83%ab%e3%83%bc%e3%83%97%e3%81%ae%e3%82%bf%e3%82%a4%e3%83%9f%e3%83%b3%e3%82%b0>#</a></h2><p>JavaScriptの並行処理モデルは、<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop>single-threaded event loop</a>に基づいており、これは一度に一つのタスクしか実行できないことを意味します。
例えば、ある時間のかかるタスクがイベントループをブロックした場合、UIスレッドが枯渇した結果として、ユーザーはページがフリーズしたように感じることがあります。
他のタスクはブロックされたタスクが終了するまで待たなければなりません。
各ブラウザは異なる<a href=https://www.chromium.org/developers/design-documents/process-models>プロセスモデル</a>を実装しているので、ウェブサイトによっては、その関係によって異なるスレッド（およびイベントループ）で実行されることがあります。</p><p>このモデルを悪用して、クロスオリジンページから秘密を盗みだす手法があります。</p><ul><li>イベントプールで次に実行されるまでの時間を測定することで、異なるオリジンのコードが実行されるまでの時間を推測する。攻撃者は固定されたプロパティを持つイベントをイベントループ<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>に送り続け、プールが空になると最終的にディスパッチされます。他のオリジンは同じプールにイベントをディスパッチし、ここで攻撃者はそのタスクの一つで遅延が発生したかどうかを検出することで、時間差を推測します。</li><li>攻撃者が制御する文字列によって前記の機密情報が比較される場合、クロスオリジンページから機密情報を盗む。このリークは、1文字ずつの文字列比較<sup id=fnref1:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>のイベントループで時間差を比較した結果です（前出の手法を使用）。<a href=https://www.chromium.org/Home/chromium-security/site-isolation>process isolation</a>を行わないブラウザでは、異なるオリジン間のクロスウィンドウ通信が同じスレッドで実行され、同じイベントループを共有します。</li></ul><blockquote class="book-hint2 important"><p class="hint-title important"><svg class="book-icon"><use href="/svg/hint-icons.svg#important-notice"/></svg><span>important</span></p>process isolationの仕組みがあるブラウザでは、後者の攻撃の可能性はすでにありません。このような仕組みは、現在Chromiumベースのブラウザでは <a href=https://www.chromium.org/Home/chromium-security/site-isolation>Site Isolation</a>のみで、Firefox には<a href=https://wiki.mozilla.org/Project_Fission>Project Fission</a> という名前で<em>間もなく</em>導入される予定です。</blockquote><h2 id=busy-event-loop>Busy Event Loop
<a class=anchor href=#busy-event-loop>#</a></h2><p>別の手法として、スレッドのイベントループをブロックし、イベントループが再び利用可能になるまでの時間を計測する方法があります。
この手法の主な利点の1つは、攻撃者のオリジンが他のオリジンの実行に影響を与えることができるため、Site Isolationを回避できることです。この攻撃は次のように動作します。</p><ol><li>対象のウェブサイトを<code>window.open</code>で別ウィンドウに表示するか、<code>iframe</code>内に表示する。(<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/xfo/>Framing Protections</a>が設定されていない場合)</li><li>長い計算が始まるのを待つ。</li><li><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/xfo/>Framing Protections</a>に関係なく、同じサイトのページを<code>iframe</code>内に読み込む</li></ol><p>攻撃者は、(手順3の)<code>iframe</code>が<code>onload</code>イベントをトリガーするのにかかった時間を計ることで、ターゲットのウェブサイトが実行された時間を検出できます。(<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/network-timing/>Network Timing</a> of step 3 should be minimal)
両方のナビゲーションは同じコンテキストで発生し、それらは同じサイトであるため、同じスレッドで実行され、同じイベントループを共有します。（それらは互いにブロックすることができます。）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#6272a4>// 新しいウィンドウを開いて、example.comのイベントループを
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ウィンドウがブロックする時間を測定する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>window</span>.open(<span style=color:#f1fa8c>&#39;https://example.org/expensive&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// TODO: タイムアウトなどでコストの掛かるウィンドウがロードされるのを待ちます。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> ifr <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.createElement(<span style=color:#f1fa8c>&#39;iframe&#39;</span>);
</span></span><span style=display:flex><span>ifr.src <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;https://example.org&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>document</span>.body.appendChild(ifr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 初期時間の測定
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>var</span> start <span style=color:#ff79c6>=</span> performance.now();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ifr.onload <span style=color:#ff79c6>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// iframeが読み込まれたら、時間差を計算する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd;font-style:italic>var</span> time <span style=color:#ff79c6>=</span> performance.now() <span style=color:#ff79c6>-</span> start;
</span></span><span style=display:flex><span>    console.log(<span style=color:#f1fa8c>&#39;It took %d ms to load the window&#39;</span>, time);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=サービスワーカー>サービスワーカー
<a class=anchor href=#%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9%e3%83%af%e3%83%bc%e3%82%ab%e3%83%bc>#</a></h2><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API>サービスワーカー</a>は、ウェブアプリケーションにオフラインソリューションを提供するために使用できますが、攻撃者によってJavaScriptの実行タイミングを計測するために悪用される可能性があります<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>。サービスワーカーは、ブラウザとネットワークの間のプロキシとして機能し、アプリケーションがメインスレッド（document）によるあらゆるネットワークリクエストを傍受することを可能にします。</p><p>タイミングを測定するために、攻撃者は以下の手順を実行することができます。</p><ol><li>攻撃者は自分のドメイン(attacker.com)の1つにサービスワーカーを登録する。</li><li>メインドキュメントで、攻撃者はターゲットウェブサイトへのナビゲーション（window.open）を発行し、サービスワーカーにタイマーを起動するよう指示する。</li><li>新しいウィンドウのロードが始まると、手順2で取得した参照をサービスワーカーが処理するページに移動させます。</li><li>手順3で実行したリクエストがサービスワーカーに到着すると、サービスワーカーは204（No Content）レスポンスを返し、ナビゲーションを中止する。</li><li>この時点で、サービスワーカーは、ステップ2で開始したタイマーの計測値を収集します。この測定値は、JavaScriptがどれくらいの時間ナビゲーションをブロックしたかに影響されます。</li></ol><p>実際にはナビゲーションは発生しないので、ステップ3から5を繰り返して、連続したJavaScriptの実行タイミングについてより多くの測定値を得ることができます。</p><h3 id=jquerycssセレクタそしてshort-circuit-timing>jQuery、CSSセレクタ、そしてShort-circuit Timing
<a class=anchor href=#jquerycss%e3%82%bb%e3%83%ac%e3%82%af%e3%82%bf%e3%81%9d%e3%81%97%e3%81%a6short-circuit-timing>#</a></h3><p>攻撃者は、CSS セレクタのもう一つの興味深い挙動である、式の<code>short-circuit</code>（短絡評価）を悪用することができます。この式は<code>URL</code>ハッシュで受け取られ、ページ<code>jQuery(location.hash)</code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>を実行したときに評価されます。</p><p>セレクタ <code>main[id='site-main']</code> がマッチせず評価に失敗すると、実行に時間のかかるセレクタの他の部分 (<code>*:has(*:has(*:has(*))))</code>) は無視されます (<code>and</code> 演算子と同じような感じですが、逆です) ので、タイミング攻撃が可能です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>$(<span style=color:#f1fa8c>&#34;*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id=&#39;site-main&#39;]&#34;</span>)
</span></span></code></pre></div><blockquote class="book-hint2 tip"><p class="hint-title tip"><svg class="book-icon"><use href="/svg/hint-icons.svg#tip-notice"/></svg><span>tip</span></p>process isolation機構を持つブラウザでは、<a href=https://webapppentestguidelines.github.io/xs-leaks/docs/attacks/timing-attacks/execution-timing/#service-workers>サービスワーカー</a>を悪用して実行タイミング計測を取得したり、<a href=#busy-event-loop>Busy Event Loop tricks</a>などでprocess isolationを回避できます。</blockquote><h2 id=redos>ReDoS
<a class=anchor href=#redos>#</a></h2><blockquote class="book-hint2 warning"><p class="hint-title warning"><svg class="book-icon"><use href="/svg/hint-icons.svg#warning-notice"/></svg><span>warning</span></p>この一連のXS-Leaksは、ターゲットページにRegexを注入することを必要とします。</blockquote><p>正規表現サービス拒否（ReDoS）とは、ユーザー入力として正規表現を許可しているアプリケーションにおいて、サービス拒否を引き起こす手法です <sup id=fnref2:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。悪意を持って細工された正規表現を指数関数的な時間で実行させることができます。これは、ページ上のデータによって異なる実行時間を持つ正規表現を注入することができる場合、XS-リークのベクトルとして使用することができます。これは、クライアントサイドまたはサーバーサイドで起こり得ます。</p><h2 id=対策>対策
<a class=anchor href=#%e5%af%be%e7%ad%96>#</a></h2><table><thead><tr><th style=text-align:center>Attack Alternative</th><th style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/same-site-cookies/>SameSite Cookies (Lax)</a></th><th style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/coop/>COOP</a></th><th style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/opt-in/xfo/>Framing Protections</a></th><th style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/>Isolation Policies</a></th></tr></thead><tbody><tr><td style=text-align:center>T. Event Loop</td><td style=text-align:center>❌</td><td style=text-align:center>❓</td><td style=text-align:center>❌</td><td style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/navigation-isolation/>NIP</a></td></tr><tr><td style=text-align:center>Service Workers</td><td style=text-align:center>✔️</td><td style=text-align:center>✔️</td><td style=text-align:center>❌</td><td style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/navigation-isolation/>NIP</a></td></tr><tr><td style=text-align:center>jQuery</td><td style=text-align:center>✔️</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/navigation-isolation/>NIP</a></td></tr><tr><td style=text-align:center>ReDoS</td><td style=text-align:center>✔️</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/navigation-isolation/>NIP</a></td></tr><tr><td style=text-align:center>Busy Event Loop</td><td style=text-align:center>✔️</td><td style=text-align:center>✔️</td><td style=text-align:center>❌</td><td style=text-align:center><a href=https://webapppentestguidelines.github.io/xs-leaks/docs/defenses/isolation-policies/navigation-isolation/>NIP</a></td></tr></tbody></table><h2 id=参考文献>参考文献
<a class=anchor href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Loophole: Timing Attacks on Shared Event Loops in Chrome, <a href=https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-vila.pdf>link</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Matryoshka - Web Application Timing Attacks (or.. Timing Attacks against JavaScript Applications in Browsers), <a href=https://sirdarckcat.blogspot.com/2014/05/matryoshka-web-application-timing.html>link</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Security: XS-Search + XSS Auditor = Not Cool, <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=922829">link</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>A timing attack with CSS selectors and Javascript, <a href=https://blog.sheddow.xyz/css-timing-attack/>link</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>A Rough Idea of Blind Regular Expression Injection Attack, <a href=https://diary.shift-js.info/blind-regular-expression-injection/>link</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/WebAppPentestGuidelines/xs-leaks//commit/acbdb2b9976df1a17987799e6cc146504a6f2cdf title='Last modified by root | August 31, 2022' target=_blank rel=noopener><img src=/xs-leaks/svg/calendar.svg class=book-icon alt=Calendar>
<span>Last Modified: August 31, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/WebAppPentestGuidelines/xs-leaks//edit/master/content//docs/attacks/timing-attacks/execution-timing.md target=_blank rel=noopener><img src=/xs-leaks/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this article</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#イベントループのタイミング>イベントループのタイミング</a></li><li><a href=#busy-event-loop>Busy Event Loop</a></li><li><a href=#サービスワーカー>サービスワーカー</a><ul><li><a href=#jquerycssセレクタそしてshort-circuit-timing>jQuery、CSSセレクタ、そしてShort-circuit Timing</a></li></ul></li><li><a href=#redos>ReDoS</a></li><li><a href=#対策>対策</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></aside></main></body></html>